/**
 * src/data/explanations/sieve-eratosthenes-explanation.ts
 *
 * エラトステネスの篩（Sieve of Eratosthenes）の解説データ
 * 古典的素数列挙アルゴリズムの学習向け
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * エラトステネスの篩の解説データ
 * 基本概念から効率的な実装、応用まで段階的に説明
 */
export const sieveEratosthenesExplanation: ExplanationData = {
	calculationType: "sieve_eratosthenes",
	title: "エラトステネスの篩とは？",
	overview:
		"エラトステネスの篩（Sieve of Eratosthenes）は、紀元前3世紀の古代ギリシャの数学者エラトステネスによって考案された、指定した範囲内のすべての素数を効率的に列挙するアルゴリズムです。O(n log log n)という優秀な時間計算量を持ち、2000年以上経った現在でも最も効率的な素数列挙法として、暗号学、数論研究、競技プログラミングなど様々な分野で広く使用されています。",

	sections: [
		{
			id: "historical-background",
			title: "📜 歴史的背景と重要性",
			content:
				"エラトステネスの篩は、古代ギリシャの数学者エラトステネス（紀元前276年頃～紀元前194年頃）によって考案されました。彼は地球の円周を初めて正確に測定したことでも知られる偉大な学者です。この篩のアルゴリズムは2000年以上前に考案されたにも関わらず、現代でも素数列挙の最も効率的な方法の一つとして使用されています。その美しいシンプルさと効率性は、古典アルゴリズムの傑作として数学史に残る重要な発見です。",
			importance: "high",
			examples: [
				"紀元前3世紀: エラトステネスによる考案",
				"中世: イスラム圏での数学研究で活用",
				"近世: オイラー、ガウスら大数学者による発展",
				"現代: コンピュータサイエンスと暗号学での基盤技術",
			],
		},

		{
			id: "algorithm-principle",
			title: "🎯 アルゴリズムの基本原理",
			content:
				"エラトステネスの篩の基本原理は「除外法」です。まず2からnまでのすべての数を素数候補として用意し、小さい素数から順にその倍数を除外していきます。最終的に除外されずに残った数がすべて素数となります。この方法の美しさは、各数について素数判定を個別に行う必要がなく、系統的な除外により効率的に素数を特定できることです。「篩（ふるい）」という名前は、不要な数を「振り落とす」動作に由来しています。",
			importance: "high",
			examples: [
				"候補準備: 2,3,4,5,6,7,8,9,10,11,12,13,...",
				"2の倍数除外: 2,3,5,7,9,11,13,15,17,19,...",
				"3の倍数除外: 2,3,5,7,11,13,17,19,23,...",
				"結果: 除外されなかった数 = 素数",
			],
		},

		{
			id: "step-by-step-process",
			title: "🔄 ステップバイステップの処理",
			content:
				"アルゴリズムは以下の手順で進行します：1) 2からnまでの数をリストに書く、2) 最小の未処理数を素数として確定、3) その素数の倍数（自分以外）をすべて除外、4) √nまで手順2-3を繰り返す、5) 残った数がすべて素数。重要な最適化として、各素数pについてp²から倍数除外を開始します。これは、p²より小さいpの倍数は既により小さい素数によって除外されているためです。",
			importance: "high",
			formula:
				"基本手順:<br>1. 候補 = {2, 3, 4, ..., n}<br>2. p = 最小の未処理数<br>3. p²からpの倍数を除外<br>4. p > √n まで繰り返し<br>5. 残り = すべて素数",
			examples: [
				"p=2: 4,6,8,10,12,14,16,18,20,... を除外",
				"p=3: 9,15,21,27,33,39,45,... を除外",
				"p=5: 25,35,55,65,85,... を除外",
				"√n超過で処理完了",
			],
		},

		{
			id: "efficiency-analysis",
			title: "⚡ 効率性の分析",
			content:
				"エラトステネスの篩の時間計算量はO(n log log n)であり、これは素数列挙アルゴリズムとして非常に優秀です。試し割り法のO(n^1.5)と比較すると大幅な改善です。この効率性の理由は、各数について個別の素数判定を行わず、系統的な除外により並列的に多数の合成数を処理できることにあります。空間計算量はO(n)で、ビット配列を使用すればさらなる省メモリ化も可能です。",
			importance: "high",
			formula:
				"計算量比較:<br>エラトステネスの篩: O(n log log n)<br>試し割り法: O(n^1.5)<br>単純判定: O(n²)<br><br>n=1000000の場合:<br>篩: 約6000万回<br>試し割り: 約10億回",
			examples: [
				"n=100: 篩≈25回 vs 試し割り≈1000回",
				"n=1000: 篩≈700回 vs 試し割り≈31,000回",
				"n=100万: 篩≈6000万回 vs 試し割り≈10億回",
				"大規模になるほど篩の優位性が顕著",
			],
		},

		{
			id: "optimization-techniques",
			title: "🚀 最適化技法",
			content:
				"エラトステネスの篩には多くの最適化技法があります。基本最適化として、p²から倍数除外を開始し、√nまでの処理で十分です。メモリ最適化では、ビット配列の使用により8分の1の省メモリ化が可能です。さらに、偶数の除外（2以外）、区間篩（segmented sieve）による大規模対応、並列化による高速化などの高度な最適化も存在します。これらの技法により、実用的な性能でより大きな範囲の素数列挙が可能になります。",
			importance: "medium",
			examples: [
				"p²開始: 小さい倍数は処理済みのためスキップ",
				"√n制限: 大きい素数の倍数チェック不要",
				"ビット配列: メモリ使用量を8分の1に削減",
				"区間篩: メモリ制約下での大規模処理",
			],
		},

		{
			id: "mathematical-properties",
			title: "📐 数学的性質と理論",
			content:
				"エラトステネスの篩は深い数学的理論に基づいています。素数定理により、n以下の素数の個数はおよそn/ln(n)で近似されます。篩の効率性は調和級数の性質と関連し、Σ(1/p) ≈ log log nという関係があります。また、篩の過程は素数の分布パターンを視覚的に示し、素数の無限性や素数間隔の変動なども観察できます。これらの性質により、篩は純粋な計算ツールを超えて、数論研究の重要な道具となっています。",
			importance: "medium",
			examples: [
				"素数定理: π(n) ≈ n/ln(n)",
				"調和級数: Σ(1/p) ≈ log log n",
				"素数間隔: 不規則だが統計的パターンあり",
				"無限性: ユークリッドの証明の視覚化",
			],
		},

		{
			id: "modern-applications",
			title: "🌐 現代での応用",
			content:
				"エラトステネスの篩は現代の様々な分野で重要な役割を果たしています。暗号学では、RSA暗号の鍵生成で大きな素数が必要になります。競技プログラミングでは、素数判定や因数分解問題の前処理として頻繁に使用されます。数論研究では、素数分布の調査や予想の検証に活用されます。また、乱数生成、ハッシュ関数、分散システムでの一意ID生成など、コンピュータサイエンスの基盤技術としても広く応用されています。",
			importance: "low",
			examples: [
				"RSA暗号: 大きな素数ペアの生成",
				"競技プログラミング: 因数分解問題の高速化",
				"数論研究: リーマン予想など未解決問題の調査",
				"システム設計: 分散ハッシュやID生成",
			],
		},

		{
			id: "implementation-variants",
			title: "💻 実装バリエーション",
			content:
				"エラトステネスの篩には用途に応じた様々な実装バリエーションがあります。標準実装では配列ベースで理解しやすく教育的です。ビット最適化版では省メモリを実現し、区間篩では大規模な範囲に対応できます。並列篩では複数コアを活用して高速化します。また、確率的篩や近似篩など、精度と速度のトレードオフを考慮した変種も研究されています。目的に応じて適切な実装を選択することが重要です。",
			importance: "medium",
			examples: [
				"標準実装: boolean配列、理解しやすい",
				"ビット最適化: メモリ効率重視",
				"区間篩: 大規模範囲対応",
				"並列篩: マルチコア活用",
			],
		},

		{
			id: "comparison-with-other-methods",
			title: "⚖️ 他の素数判定法との比較",
			content:
				"素数列挙には複数の手法がありますが、それぞれに特徴があります。試し割り法は実装が簡単ですが、大量の素数列挙には非効率です。ミラー・ラビン判定法は確率的ですが、個別の大きな数の素数判定に適しています。AKS判定法は決定的多項式時間ですが、実用性は限定的です。エラトステネスの篩は、中程度の範囲での全素数列挙において最も効率的で実用的な選択肢です。",
			importance: "low",
			examples: [
				"試し割り法: 簡単だが非効率（O(n^1.5)）",
				"ミラー・ラビン: 確率的、大きな数向け",
				"AKS: 決定的だが実用性低い",
				"篩: 範囲内全列挙で最効率",
			],
		},

		{
			id: "educational-value",
			title: "📚 教育的価値と学習意義",
			content:
				"エラトステネスの篩は、アルゴリズム学習において非常に高い教育的価値を持ちます。アルゴリズムの概念が直感的で理解しやすく、効率性の重要性を実感できます。数学（素数論）とコンピュータサイエンス（アルゴリズム）の美しい融合例として、学問の関連性を学べます。また、古典的知識が現代技術の基盤となっていることを示す好例でもあります。プログラミング的には、配列操作、ループ制御、最適化技法などの基本スキルも習得できます。",
			importance: "low",
			examples: [
				"直感的理解: 篩のメタファーで概念把握",
				"効率性実感: 大きなnでの計算時間差",
				"数学との融合: 純粋数学と応用技術の統合",
				"古典と現代: 2000年前の知恵が現代技術を支える",
			],
		},

		{
			id: "common-pitfalls",
			title: "⚠️ よくある間違いと注意点",
			content:
				"エラトステネスの篩の実装では、いくつかの典型的な間違いがあります。インデックス管理では、配列の0ベースと数値の1ベースの混同が頻発します。最適化の実装では、p²からの開始を忘れる、√nの範囲制限を適用しないなどがあります。メモリ関連では、大きなnに対する配列サイズの制限を考慮しない場合があります。また、結果の検証では、既知の素数列との照合を怠ると間違いに気づかない可能性があります。",
			importance: "medium",
			examples: [
				"インデックス混同: 0ベース配列と1ベース数値",
				"最適化忘れ: p²開始や√n制限の未実装",
				"メモリ超過: 大きなnでの配列サイズ問題",
				"検証不足: 既知素数列との照合忘れ",
			],
		},

		{
			id: "learning-progression",
			title: "📖 学習の進め方",
			content:
				"エラトステネスの篩の学習は、まず手動での小さな例（n=30程度）から始めることをお勧めします。アルゴリズムの動作を理解した後、基本的な実装を行い、その後段階的に最適化を追加していきます。ビット最適化、区間篩、並列化などの高度な技法に進む前に、基本形を完全に理解することが重要です。最終的には、暗号学や競技プログラミングでの実用例を学習し、理論と実践の橋渡しを行います。各段階で計算量の変化を実測することで、最適化の効果を体感できます。",
			importance: "low",
			examples: [
				"基礎: 手動計算でアルゴリズム理解",
				"実装: 基本版から最適化版への発展",
				"応用: 暗号学、競プロでの活用例",
				"発展: 大規模データと高度な最適化",
			],
		},
	],
};
