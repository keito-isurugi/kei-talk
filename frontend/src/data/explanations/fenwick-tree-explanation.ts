/**
 * src/data/explanations/fenwick-tree-explanation.ts
 *
 * Fenwick Tree（Binary Indexed Tree）の解説データ
 * ビット演算による累積和の効率的な計算と一点更新の理論と実装
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * Fenwick Tree（Binary Indexed Tree）の解説データ
 * 基本概念から高度な応用まで段階的に説明
 */
export const fenwickTreeExplanation: ExplanationData = {
	calculationType: "fenwick_tree",
	title: "Fenwick Tree（Binary Indexed Tree）とは？",
	overview:
		"Fenwick Tree（Binary Indexed Tree, BIT）は、累積和の効率的な計算と一点更新を実現するデータ構造です。1994年にPeter Fenwickによって発明され、ビット演算を用いた巧妙な実装により、シンプルながら非常に高性能を発揮します。構築O(n log n)、クエリ・更新O(log n)の時間計算量で、配列による実装が可能なため実装が簡潔です。lowbit操作（x & -x）による親子関係の計算が核心となり、セグメント木と比較して実装が短く、定数倍が小さく、メモリ使用量も少ない特徴があります。累積和に特化することで最適化された、実用性の高いデータ構造です。",

	sections: [
		{
			id: "bit-manipulation-core",
			title: "🔢 ビット演算の核心：lowbit操作",
			content:
				"Fenwick Treeの核心は、lowbit操作（x & -x）にあります。この演算は、整数xの最下位の1ビットのみを抽出し、他の全てのビットを0にします。例えば、12（1100₂）のlowbitは4（0100₂）となります。この操作により、親子関係を効率的に計算でき、更新時は「index += lowbit(index)」、クエリ時は「index -= lowbit(index)」で次のノードに移動します。2の補数表現（-x = ~x + 1）を利用することで、この操作が可能になります。lowbit操作により、各ノードが担当する範囲の大きさが決まり、効率的な範囲管理を実現します。この巧妙なビット演算により、複雑な木構造をシンプルな配列操作で実現し、Fenwick Treeの優秀な性能の基盤となっています。",
			importance: "high",
			examples: [
				"lowbit(12) = 12 & (-12) = 1100₂ & 0100₂ = 0100₂ = 4",
				"lowbit(6) = 6 & (-6) = 0110₂ & 1010₂ = 0010₂ = 2",
				"更新: index += lowbit(index) で上位ノードへ",
				"クエリ: index -= lowbit(index) で必要ノードを収集",
			],
			formula:
				"lowbit操作:<br>lowbit(x) = x & (-x)<br><br>2の補数:<br>-x = ~x + 1<br><br>移動操作:<br>• 更新: index += lowbit(index)<br>• クエリ: index -= lowbit(index)<br><br>担当範囲サイズ: lowbit(index)",
		},

		{
			id: "array-implementation",
			title: "📊 1-based配列による効率的実装",
			content:
				"Fenwick Treeは1-basedの配列で実装することで、親子関係の計算が非常にシンプルになります。0-basedでは複雑になるビット演算が、1-basedでは自然に動作します。配列のインデックス1から開始し、tree[i]には特定の範囲の累積和が格納されます。各ノードiが担当する範囲は、[i - lowbit(i) + 1, i]となり、lowbit(i)個の連続する要素の和を管理します。この実装により、ポインタが不要で、メモリ効率が良く、キャッシュ効率も優秀です。また、配列アクセスのオーバーヘッドが小さく、実際の実行時間がセグメント木より高速になることが多いです。1-basedインデックスは最初は慣れが必要ですが、この実装方式により得られる利益は非常に大きいです。",
			importance: "high",
			examples: [
				"1-based: インデックス1から開始、計算が簡潔",
				"tree[6]: [6-lowbit(6)+1, 6] = [5, 6]の和を管理",
				"tree[8]: [8-lowbit(8)+1, 8] = [1, 8]の和を管理",
				"メモリ効率: ポインタ不要、連続領域使用",
			],
			formula:
				"ノードiの担当範囲:<br>[i - lowbit(i) + 1, i]<br><br>例：<br>• tree[6]: 範囲[5,6] (lowbit(6)=2)<br>• tree[8]: 範囲[1,8] (lowbit(8)=8)<br>• tree[5]: 範囲[5,5] (lowbit(5)=1)",
		},

		{
			id: "update-mechanism",
			title: "📝 一点更新の伝播メカニズム",
			content:
				"Fenwick Treeの一点更新は、指定されたインデックスから開始して、影響を受ける全ての上位ノードを順次更新します。更新対象のインデックスiから、「i += lowbit(i)」の操作を繰り返すことで、iを含む全ての範囲を管理するノードを効率的に特定できます。各ステップで現在のノードの値に差分を加算し、配列の境界を超えるまで継続します。この処理により、O(log n)回の更新でFenwick Tree全体の一貫性を保てます。lowbit操作の性質により、必要なノードのみを正確に更新でき、不要な計算を完全に回避できます。また、加算による更新だけでなく、差分を利用することで任意の値への設定も可能で、柔軟な操作を提供します。",
			importance: "high",
			examples: [
				"更新index=3: 3→4→8→16→... と伝播",
				"更新index=6: 6→8→16→... と伝播",
				"伝播回数: 最大O(log n)回",
				"差分更新: add(i, value - old_value)で設定操作",
			],
			formula:
				"更新アルゴリズム:<br>function add(index, value):<br>&nbsp;&nbsp;while index ≤ n:<br>&nbsp;&nbsp;&nbsp;&nbsp;tree[index] += value<br>&nbsp;&nbsp;&nbsp;&nbsp;index += lowbit(index)<br><br>設定操作:<br>set(i, v) = add(i, v - get(i))",
		},

		{
			id: "prefix-sum-query",
			title: "🔍 累積和クエリの効率的計算",
			content:
				"Fenwick Treeの累積和クエリは、インデックス1からiまでの合計を効率的に計算します。クエリ対象のインデックスiから開始し、「i -= lowbit(i)」の操作を繰り返すことで、必要な範囲の和を持つノードを収集します。各ステップで現在のノードの値を合計に加算し、インデックスが0になるまで継続します。この処理により、O(log n)回の加算で正確な累積和を得られます。範囲和クエリ[l, r]は、prefixSum(r) - prefixSum(l-1)として計算でき、2回の累積和クエリで実現できます。lowbit操作により必要最小限のノードのみアクセスするため、効率的で高速な計算が可能です。この巧妙な設計により、シンプルな実装で優秀な性能を実現しています。",
			importance: "high",
			examples: [
				"prefixSum(7): 7→6→4→0 でノードを収集",
				"prefixSum(12): 12→8→0 でノードを収集",
				"範囲和[3,7]: prefixSum(7) - prefixSum(2)",
				"アクセス回数: 最大O(log n)個のノード",
			],
			formula:
				"累積和クエリ:<br>function prefixSum(index):<br>&nbsp;&nbsp;sum = 0<br>&nbsp;&nbsp;while index > 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;sum += tree[index]<br>&nbsp;&nbsp;&nbsp;&nbsp;index -= lowbit(index)<br>&nbsp;&nbsp;return sum<br><br>範囲和: sum(l,r) = prefixSum(r) - prefixSum(l-1)",
		},

		{
			id: "construction-methods",
			title: "🏗️ 構築方法と初期化戦略",
			content:
				"Fenwick Treeの構築には、複数の方法があります。最も直感的な方法は、元の配列の各要素を順次add操作で追加する逐次構築で、時間計算量はO(n log n)となります。より効率的な方法として、ボトムアップ構築があり、各ノードの値を直接計算することでO(n)で構築できます。逐次構築は実装が簡単で理解しやすく、初期化コストが問題にならない場合に適しています。ボトムアップ構築は理論的に最適ですが、実装が複雑になります。実用的には、データサイズと使用頻度を考慮して選択します。また、空のFenwick Treeから開始して動的に要素を追加する用途では、逐次構築が自然な選択となります。どちらの方法でも、最終的に同じ構造のFenwick Treeが構築されます。",
			importance: "medium",
			examples: [
				"逐次構築: for i in 1..n: add(i, array[i])",
				"時間計算量: O(n log n) vs O(n)",
				"実装難易度: 簡単 vs 複雑",
				"用途選択: 初期化頻度と性能要件で決定",
			],
			formula:
				"逐次構築:<br>for i = 1 to n:<br>&nbsp;&nbsp;add(i, array[i])<br>計算量: O(n log n)<br><br>ボトムアップ構築:<br>直接計算によりO(n)で構築<br>（実装は複雑）",
		},

		{
			id: "segment-tree-comparison",
			title: "⚖️ セグメント木との比較",
			content:
				"Fenwick Treeとセグメント木は、どちらも範囲クエリと一点更新を効率的に処理しますが、異なる特性を持ちます。Fenwick Treeは累積和に特化し、実装が非常にシンプルで、メモリ使用量がセグメント木の1/4程度、定数倍が小さく実際の実行時間が高速です。一方、セグメント木は任意の結合可能演算をサポートし、構築がO(n)、理論的に汎用的です。Fenwick Treeは累積和、区間和クエリが主な用途で、コードが短く実装ミスが少ないです。セグメント木は最小値、最大値、GCD、複雑な演算など幅広い用途に対応できます。競技プログラミングでは、累積和系の問題ならFenwick Tree、その他はセグメント木という使い分けが一般的です。どちらを選ぶかは、問題の要件と実装の簡潔性のバランスで決まります。",
			importance: "medium",
			examples: [
				"実装: Fenwick Tree 20行 vs セグメント木 50行",
				"メモリ: FT O(n) vs ST O(4n)",
				"汎用性: FT 累積和のみ vs ST 任意演算",
				"構築: FT O(n log n) vs ST O(n)",
			],
			formula:
				"比較表:<br>実装簡潔性: FT ◎ vs ST ○<br>メモリ効率: FT ◎ vs ST △<br>実行速度: FT ◎ vs ST ○<br>汎用性: FT △ vs ST ◎<br>構築速度: FT ○ vs ST ◎",
		},

		{
			id: "2d-fenwick-tree",
			title: "🏢 二次元Fenwick Tree",
			content:
				"二次元Fenwick Treeは、二次元配列に対する矩形範囲の累積和クエリと一点更新を効率的に処理します。一次元版を二重に適用し、行と列の両方向でlowbit操作を使用します。構築はO(nm log n log m)、クエリと更新はO(log n log m)の時間計算量となります。実装では、tree[i][j]が矩形領域の累積和を保持し、更新時は両次元でlowbit操作による伝播を行います。矩形範囲[x1,y1,x2,y2]のクエリは、4つの累積和の加減算で計算できます。画像処理での矩形領域統計、二次元累積和テーブルの動的版、ゲーム開発での範囲判定などで応用されます。メモリ使用量はO(nm)と大きくなりますが、更新性能の優位性により、動的な二次元範囲クエリでは有効な選択肢となります。座標圧縮と組み合わせることで、疎なデータも効率的に処理できます。",
			importance: "low",
			examples: [
				"矩形クエリ: sum(x2,y2) - sum(x1-1,y2) - sum(x2,y1-1) + sum(x1-1,y1-1)",
				"更新伝播: 両次元でlowbit操作を適用",
				"空間計算量: O(nm) - 大きなデータでは注意",
				"応用: 画像統計、ゲーム範囲判定",
			],
		},

		{
			id: "coordinate-compression",
			title: "🗜️ 座標圧縮との組み合わせ",
			content:
				"座標圧縮は、大きな座標空間を扱う際にFenwick Treeの実用性を大幅に向上させる技法です。例えば、座標が1から10^9の範囲にあるが、実際に使用される座標が1000個程度の場合、全ての座標を配列で管理するのは非効率的です。座標圧縮では、使用される座標のみを取り出してソートし、0からn-1の連続したインデックスに再マッピングします。これにより、メモリ使用量をO(実際の要素数)に削減でき、大規模な座標でもFenwick Treeを適用できます。実装では、座標の前処理（重複除去、ソート）、座標→インデックスの変換テーブル作成、クエリ時の座標変換が必要です。この技法により、競技プログラミングでの大座標問題や、実世界での疎なデータ処理において、Fenwick Treeの適用範囲が大幅に拡大されます。",
			importance: "low",
			examples: [
				"問題: 座標10^9、使用1000個 → 配列1000個で処理",
				"前処理: 座標収集、ソート、重複除去",
				"変換: 元座標 → 圧縮後インデックス",
				"利益: メモリO(10^9) → O(実際の要素数)",
			],
		},

		{
			id: "inversion-counting",
			title: "🔄 転倒数計算への応用",
			content:
				"転倒数（逆順ペア数）の計算は、Fenwick Treeの典型的な応用例の一つです。配列において、i < j かつ a[i] > a[j] となるペア(i,j)の個数を効率的に求める問題です。単純な方法ではO(n²)の時間がかかりますが、Fenwick Treeを使用することでO(n log n)に改善できます。アルゴリズムでは、配列を左から右にスキャンし、各要素について「その要素より大きい値で既に処理された要素の個数」をFenwick Treeで計算します。座標圧縮と組み合わせることで、値の範囲に関係なく効率的に処理できます。この応用は、ソートアルゴリズムの効率性解析、統計学での順位相関、バブルソートの交換回数計算などで重要です。また、より一般的な「条件を満たすペアの個数」問題にも応用できる汎用的な技法です。",
			importance: "low",
			examples: [
				"定義: i < j かつ a[i] > a[j] のペア(i,j)の個数",
				"処理: 左から右にスキャン、大きい値の個数をクエリ",
				"更新: 現在の値をFenwick Treeに追加",
				"計算量: O(n²) → O(n log n)に改善",
			],
			formula:
				"転倒数計算:<br>count = 0<br>for i = 0 to n-1:<br>&nbsp;&nbsp;count += query(max_val) - query(a[i])<br>&nbsp;&nbsp;update(a[i], 1)<br><br>時間計算量: O(n log n)",
		},

		{
			id: "range-update-variant",
			title: "📋 範囲更新対応版",
			content:
				"基本的なFenwick Treeは一点更新のみサポートしますが、差分配列と組み合わせることで範囲更新も効率的に処理できます。差分配列では、区間[l,r]にvを加算する操作を、diff[l] += v, diff[r+1] -= vの2回の一点更新で表現します。元の値は差分配列の累積和として求められ、Fenwick Treeで差分配列を管理することで、範囲更新と一点クエリをO(log n)で実行できます。また、2つのFenwick Treeを使用することで、範囲更新と範囲クエリの両方をO(log n)で処理する方法もあります。これにより、遅延評価付きセグメント木と同等の機能をより簡潔な実装で実現できます。競技プログラミングでの区間更新問題や、実用システムでのバッチ更新処理において、実装の簡潔性という大きな利点を提供します。",
			importance: "low",
			examples: [
				"差分配列: 範囲[l,r]更新 → diff[l]+=v, diff[r+1]-=v",
				"一点クエリ: 差分配列の累積和",
				"2つのBIT: 範囲更新 + 範囲クエリ対応",
				"利点: 遅延評価より実装が簡潔",
			],
		},

		{
			id: "competitive-programming-usage",
			title: "🏆 競技プログラミングでの活用",
			content:
				"Fenwick Treeは競技プログラミングにおいて極めて重要なデータ構造です。累積和系の問題、転倒数計算、座標圧縮との組み合わせ、動的な順位計算などで頻繁に使用されます。実装が短く（20行程度）、バグが入りにくく、実行時間も高速なため、コンテスト環境での信頼性が高いです。テンプレート化により、add、sum、rangeSum関数を標準化し、使い回しが容易です。また、座標圧縮、二次元版、範囲更新版など、問題に応じた拡張も実装しておくと有効です。時間制限が厳しい問題では、Fenwick Treeの定数倍の小ささが決定的な差になることがあります。セグメント木と使い分けることで、累積和問題での実装時間短縮と、実行時間の高速化を同時に実現できます。競技プログラマーの必須知識として位置づけられています。",
			importance: "medium",
			examples: [
				"実装: 20行程度の簡潔なコード",
				"信頼性: バグが入りにくい構造",
				"高速性: セグメント木より実行時間が短い",
				"拡張: 座標圧縮、2D、範囲更新版",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実用システムでの応用",
			content:
				"Fenwick Treeは、実用システムでも様々な場面で活用されています。データベースでは、インデックスの一部として累積統計の高速計算に使用されます。ゲーム開発では、リーダーボードの動的ランキング、経験値システムでの累積計算、リアルタイム統計処理に応用されます。金融システムでは、取引量の累積計算、時系列データの移動統計、リスク計算での範囲集計に使用されます。Webアプリケーションでは、アクセス統計、ユーザー行動分析、A/Bテストでの集計処理に活用されます。IoTシステムでは、センサーデータの累積監視、異常検出での閾値判定、エネルギー消費量の計算に使用されます。これらの応用では、Fenwick Treeの実装の簡潔性とメモリ効率の良さが、システムの保守性と性能の両立に貢献しています。",
			importance: "low",
			examples: [
				"ゲーム: リーダーボード、経験値システム",
				"金融: 取引統計、時系列集計",
				"Web: アクセス解析、ユーザー統計",
				"IoT: センサー監視、エネルギー計算",
			],
		},

		{
			id: "implementation-tips",
			title: "💡 実装のコツと注意点",
			content:
				"Fenwick Treeの実装では、いくつかの重要なコツと注意点があります。1-basedインデックスの徹底により、lowbit操作が正しく動作するよう注意が必要です。0-basedの元配列から1-basedのFenwick Treeへの変換を正確に行います。型の選択では、累積和がオーバーフローしないよう適切な整数型を使用します。エラーハンドリングでは、範囲外アクセスや負のインデックスを適切に検出します。性能最適化では、lowbit操作のインライン化、ループの最適化、キャッシュ効率の考慮が効果的です。また、テストケースでは、境界値（インデックス1、最大インデックス）、空の配列、単一要素などを確認します。デバッグ時は、tree配列の内容を可視化する関数を用意すると理解が深まります。これらの配慮により、正確で効率的なFenwick Treeを実装できます。",
			importance: "medium",
			examples: [
				"インデックス: 1-based徹底、変換の正確性",
				"型選択: オーバーフロー対策",
				"最適化: lowbitインライン化、キャッシュ効率",
				"テスト: 境界値、空配列、単一要素",
			],
		},

		{
			id: "educational-value",
			title: "📚 教育的価値と学習意義",
			content:
				"Fenwick Treeは、データ構造とアルゴリズムの学習において独特の教育的価値を持ちます。ビット演算の実践的応用を通じて、コンピュータの内部表現と効率的な計算の関係を理解できます。シンプルな実装で高性能を実現する設計の美しさを体験でき、「複雑さを避けて本質に集中する」というアルゴリズム設計の重要な原則を学べます。また、セグメント木との比較を通じて、問題に特化した最適化の価値と、汎用性とのトレードオフを理解できます。累積和という基本的な概念を効率的に実現する過程で、実用的なデータ構造設計の考え方を習得できます。さらに、座標圧縮、転倒数計算などの応用を通じて、単一のデータ構造が様々な問題に適用できることを学び、アルゴリズム的思考力の向上に寄与します。",
			importance: "low",
			examples: [
				"ビット演算: 実践的応用と効率化",
				"設計哲学: シンプルさと性能の両立",
				"比較学習: セグメント木との使い分け",
				"応用展開: 一つの技法の多様な活用",
			],
		},
	],
};
