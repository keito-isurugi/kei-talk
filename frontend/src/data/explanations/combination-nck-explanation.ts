/**
 * src/data/explanations/combination-nck-explanation.ts
 *
 * nCk組み合わせ計算（Combination）の解説データ
 * 数学的基礎から効率的実装まで段階的に説明する教育向けデータ
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * nCk組み合わせ計算の解説データ
 * 基本概念から実用的応用まで包括的に説明
 */
export const combinationNCkExplanation: ExplanationData = {
	calculationType: "combination_nck",
	title: "nCk組み合わせ計算とは？",
	overview:
		"nCk組み合わせ計算（Combination）は、n個の要素からk個を順序を考慮せずに選ぶ場合の数を求める基本的な数学的アルゴリズムです。C(n,k) = n!/(k!×(n-k)!)の公式で表され、確率論、統計学、組合せ最適化において中核的な役割を果たしています。効率的な計算手法として、階乗による直接計算、最適化された逐次計算、パスカルの三角形を用いた動的計画法など複数のアプローチがあり、数値の安定性と計算効率の両立が重要な技術課題となっています。",

	sections: [
		{
			id: "mathematical-foundation",
			title: "📐 数学的基礎と定義",
			content:
				"組み合わせC(n,k)は、n個の異なる要素からk個を順序を考慮せずに選ぶ場合の数です。基本公式はC(n,k) = n!/(k!×(n-k)!)で表され、これは全ての順列n!を、選んだk個の内部順列k!と選ばなかった(n-k)個の内部順列(n-k)!で割ることで順序を除去します。重要な性質として対称性C(n,k) = C(n,n-k)があり、これは「k個選ぶ」ことと「(n-k)個残す」ことが同じであることを意味します。境界条件としてC(n,0) = C(n,n) = 1（何も選ばない/全て選ぶ）、C(n,1) = n（1個選ぶ）が成り立ちます。",
			importance: "high",
			examples: [
				"C(5,2) = 5!/(2!×3!) = 120/(2×6) = 10",
				"C(4,0) = 1（何も選ばない場合）",
				"C(6,3) = C(6,6-3) = C(6,3) = 20（対称性）",
				"C(7,1) = 7（1個選ぶ場合は要素数と同じ）",
			],
			formula:
				"基本公式:<br>C(n,k) = n!/(k!×(n-k)!)<br><br>対称性:<br>C(n,k) = C(n,n-k)<br><br>境界条件:<br>C(n,0) = C(n,n) = 1<br>C(n,1) = C(n,n-1) = n",
		},

		{
			id: "pascal-triangle",
			title: "🔺 パスカルの三角形と漸化式",
			content:
				"パスカルの三角形は組み合わせ数の美しい表現で、各要素がC(n,k)に対応します。基本となるパスカルの恒等式C(n,k) = C(n-1,k-1) + C(n-1,k)は、「n個からk個選ぶ方法」を「特定の1個を含む場合」と「含まない場合」に分割する組み合わせ論的証明に基づきます。この漸化式により動的計画法でのボトムアップ計算が可能になり、大きな階乗計算を回避できます。三角形の各行は二項係数(a+b)^nの展開係数に対応し、確率論での二項分布の基礎となります。空間効率化により必要な部分のみを計算することで、O(min(k,n-k))の空間計算量を実現できます。",
			importance: "high",
			examples: [
				"行0: 1（C(0,0)）",
				"行1: 1, 1（C(1,0), C(1,1)）",
				"行2: 1, 2, 1（C(2,0), C(2,1), C(2,2)）",
				"行3: 1, 3, 3, 1（C(3,0), C(3,1), C(3,2), C(3,3)）",
			],
			formula:
				"パスカルの恒等式:<br>C(n,k) = C(n-1,k-1) + C(n-1,k)<br><br>動的計画法の遷移:<br>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]<br><br>空間最適化:<br>必要な範囲のみ計算してO(min(k,n-k))に削減",
		},

		{
			id: "factorial-method",
			title: "🔢 階乗による直接計算法",
			content:
				"階乗による直接計算はC(n,k) = n!/(k!×(n-k)!)の公式をそのまま実装する最も直感的な方法です。数学的定義に忠実で理解しやすい一方、階乗の急激な増加により数値オーバーフローが発生しやすい問題があります。n!は非常に大きくなるため（10! = 3,628,800、15! ≈ 1.3×10^12）、実用的にはn ≤ 15程度に制限されます。この方法の教育的価値は高く、組み合わせの定義を明確に示しますが、実装時は中間結果の桁数管理と精度保持が重要な課題となります。大きな数値での計算には後述の最適化手法が必要です。",
			importance: "medium",
			examples: [
				"C(5,2): 5! = 120, 2! = 2, 3! = 6 → 120/(2×6) = 10",
				"C(4,1): 4! = 24, 1! = 1, 3! = 6 → 24/(1×6) = 4",
				"オーバーフロー例: 20! ≈ 2.4×10^18（JavaScript限界付近）",
				"安全範囲: n ≤ 15で確実な整数計算",
			],
		},

		{
			id: "optimized-calculation",
			title: "⚡ 最適化された効率的計算法",
			content:
				"最適化された計算法は、対称性C(n,k) = C(n,n-k)を活用してmin(k, n-k)で計算することで効率を大幅に向上させます。さらに、階乗を直接計算せず、乗算と除算を交互に行うことで中間結果を小さく保ち、オーバーフローを回避します。具体的には、C(n,k) = (n×(n-1)×...×(n-k+1))/(k×(k-1)×...×1)として、分子と分母を同時に構築しながら約分を進めます。この手法により時間計算量をO(min(k, n-k))に削減し、空間計算量はO(1)を維持できます。数値の安定性も向上し、実用的な範囲での正確な計算が可能になります。",
			importance: "high",
			examples: [
				"C(10,7) → C(10,3)に変換して計算量削減",
				"C(8,3): (8×7×6)/(3×2×1) = 336/6 = 56",
				"逐次計算: result = result × (n-i) / (i+1)",
				"中間結果制御: 常に整数を維持",
			],
			formula:
				"最適化公式:<br>C(n,k) = C(n,min(k,n-k))<br><br>逐次計算:<br>result = 1<br>for i = 0 to min(k,n-k)-1:<br>&nbsp;&nbsp;result = result × (n-i) / (i+1)<br><br>計算量削減:<br>O(k) → O(min(k,n-k))",
		},

		{
			id: "iterative-safe-method",
			title: "🛡️ 安全な逐次計算法",
			content:
				"安全な逐次計算法は、数値の安定性を最優先に設計された実装です。乗算と除算の順序を工夫することで、すべての中間結果が整数になることを保証し、浮動小数点誤差を完全に排除します。この方法では、各ステップでresult = (result × 分子) / 分母の計算を行い、除算が常に割り切れることを数学的に保証します。特に、コンピュータの数値表現の限界内での正確な計算が必要な用途（暗号学、正確な確率計算など）において重要です。また、計算過程が直感的で検証しやすく、教育目的やデバッグ時の信頼性が高い特徴があります。",
			importance: "medium",
			examples: [
				"整数保証: 各ステップで必ず整数結果",
				"安全な除算: 分子が分母で必ず割り切れる",
				"誤差回避: 浮動小数点演算を最小化",
				"検証容易: 中間結果の妥当性確認が簡単",
			],
		},

		{
			id: "complexity-analysis",
			title: "📊 計算量分析と効率性比較",
			content:
				"各計算手法の計算量特性を比較すると、階乗法はO(n)、最適化法・逐次法はO(min(k, n-k))、パスカル法はO(n×min(k, n-k))となります。空間計算量では、階乗法・最適化法・逐次法がO(1)、パスカル法がO(min(k, n-k))です。実用性の観点から、k≪nまたはk≫nの場合は最適化法が最も効率的で、複数の組み合わせを連続計算する場合はパスカル法が有利です。大きなnに対してはオーバーフロー耐性が重要で、数値の安定性を重視する場合は逐次法が推奨されます。計算精度と効率のトレードオフを理解し、用途に応じた手法選択が重要です。",
			importance: "high",
			examples: [
				"階乗法: O(n)時間、O(1)空間、n≤15制限",
				"最適化法: O(min(k,n-k))時間、O(1)空間、推奨",
				"パスカル法: O(n×min(k,n-k))時間、O(min(k,n-k))空間",
				"逐次法: O(min(k,n-k))時間、O(1)空間、最安全",
			],
			formula:
				"計算量比較:<br>階乗法: O(n) 時間, O(1) 空間<br>最適化法: O(min(k,n-k)) 時間, O(1) 空間<br>パスカル法: O(n×min(k,n-k)) 時間, O(min(k,n-k)) 空間<br>逐次法: O(min(k,n-k)) 時間, O(1) 空間",
		},

		{
			id: "probability-applications",
			title: "🎲 確率論での応用",
			content:
				"組み合わせ計算は確率論の基盤として広範囲に応用されます。二項分布P(X=k) = C(n,k)×p^k×(1-p)^(n-k)では組み合わせ数が確率計算の核心となり、統計的推論やベイズ統計での事前分布・事後分布計算に不可欠です。サンプリング理論では、母集団からの標本抽出パターン数の計算、層化抽出でのサンプルサイズ決定に使用されます。実際の応用例として、品質管理での不良品検出確率、医療統計での薬効評価、マーケティングでの顧客セグメント分析などがあります。現代のデータサイエンスでも、特徴選択やクロスバリデーションでの分割パターン計算に重要な役割を果たしています。",
			importance: "medium",
			examples: [
				"二項分布: C(10,3)×0.3³×0.7⁷ ≈ 0.267",
				"サンプリング: 100人から10人選ぶ方法数 = C(100,10)",
				"品質管理: 20個中3個不良の確率計算",
				"A/Bテスト: 実験群の組み合わせ数計算",
			],
		},

		{
			id: "combinatorial-optimization",
			title: "🔧 組合せ最適化での活用",
			content:
				"組合せ最適化では、組み合わせ数が解空間の大きさを表現し、アルゴリズムの効率性評価に使用されます。ナップサック問題では、C(n,k)が部分集合の候補数を示し、動的計画法の状態数を予測できます。グラフ理論では、頂点集合の部分集合を扱う問題（最大独立集合、頂点被覆など）で組み合わせ数が解析的複雑さを表します。機械学習では、特徴選択でC(特徴数, 選択数)が探索空間を定義し、アンサンブル学習でのモデル組み合わせ数の計算に応用されます。近似アルゴリズムの性能保証や、確率的アルゴリズムの期待計算量解析でも重要な役割を果たします。",
			importance: "medium",
			examples: [
				"特徴選択: 100特徴から10個選ぶ → C(100,10) ≈ 4.3×10^13通り",
				"ナップサック: n個アイテムの部分集合 = 2^n = Σ C(n,k)",
				"クラスタリング: データポイントの組み合わせ評価",
				"スケジューリング: タスクの実行順序組み合わせ",
			],
		},

		{
			id: "cryptography-applications",
			title: "🔐 暗号学と情報セキュリティ",
			content:
				"暗号学では組み合わせ数が鍵空間の大きさや攻撃計算量の評価に使用されます。共有秘密分散方式では、n個の秘密の断片からk個で復元可能な(k,n)閾値暗号において、C(n,k)が復元可能な組み合わせ数を表します。ブロック暗号の安全性解析では、差分解読法や線形解読法での特性組み合わせ数が重要です。公開鍵暗号では、RSA暗号の安全性が素因数分解の困難性に依存し、候補素数の組み合わせ数が安全性指標となります。また、ハッシュ関数の衝突確率計算や、ランダムネス検定での統計的評価にも組み合わせ数が基礎理論として活用されています。",
			importance: "low",
			examples: [
				"秘密分散: (3,5)閾値でC(5,3) = 10通りの復元方法",
				"鍵空間: 128bit鍵のサブキー組み合わせ評価",
				"攻撃計算量: 全数探索での組み合わせ数推定",
				"認証: パスワード組み合わせの強度評価",
			],
		},

		{
			id: "numerical-stability",
			title: "⚖️ 数値計算の安定性と精度",
			content:
				"組み合わせ計算における数値安定性は、正確な結果を得るための重要な技術課題です。階乗の急激な増加により生じるオーバーフローは、中間結果の管理と適切な計算順序により回避できます。浮動小数点演算の精度誤差は、可能な限り整数演算を維持することで最小化されます。特に、除算を最後に行う、または乗算と除算を交互に実行して中間値を制御する手法が効果的です。大きな数値での計算では、対数変換log(C(n,k)) = log(n!) - log(k!) - log((n-k)!)を使用して数値範囲を制御する方法もあります。精度保証のため、異なる手法での結果比較や、既知の組み合わせ恒等式を用いた検証も重要です。",
			importance: "medium",
			examples: [
				"オーバーフロー回避: 乗除算の適切な順序",
				"精度保持: 整数演算の最大活用",
				"対数変換: log(C(n,k))での安全な計算",
				"検証: 異なる手法での結果一致確認",
			],
		},

		{
			id: "implementation-patterns",
			title: "💻 実装パターンと最適化技法",
			content:
				"効率的な組み合わせ計算の実装では、複数のパターンが考えられます。単発計算では最適化された逐次計算が推奨され、連続計算ではパスカルの三角形による前計算が有効です。メモ化により既計算結果を再利用することで、重複計算を避けられます。大規模計算では、並列処理により複数の組み合わせを同時計算できます。また、近似計算として、Stirlingの公式を用いた近似値計算や、モンテカルロ法による確率的推定も選択肢となります。実装時は、入力検証、エラーハンドリング、型安全性の確保が重要で、特に境界条件（k=0, k=n）の適切な処理が必要です。",
			importance: "medium",
			examples: [
				"メモ化: 計算済み結果をキャッシュして再利用",
				"並列処理: 複数の組み合わせを同時計算",
				"近似計算: Stirlingの公式で大数近似",
				"型安全: 入力検証とオーバーフロー検出",
			],
		},

		{
			id: "educational-value",
			title: "📚 教育的価値と学習意義",
			content:
				"nCk組み合わせ計算は、数学とコンピュータサイエンスの交差点に位置する優れた教材です。数学的には、組み合わせ論の基礎概念、階乗と漸化式の理解、対称性などの重要な性質を学べます。アルゴリズム設計の観点では、異なるアプローチの比較、効率性の分析、数値安定性の考慮を通じて、実践的なプログラミング技術を習得できます。さらに、確率論、統計学、暗号学への応用を通じて、理論と実践の架け橋となる学習体験を提供します。動的計画法の導入教材としても優秀で、最適部分構造の理解やボトムアップ計算の習得に適しています。現代のデータサイエンス時代において、組み合わせ数学の重要性は増大しており、基礎から応用まで幅広い学習価値を持ちます。",
			importance: "low",
			examples: [
				"数学理解: 組み合わせ論の基礎概念習得",
				"アルゴリズム: 効率的計算手法の比較学習",
				"応用展開: 確率論から暗号学まで広範囲",
				"実践技術: 数値計算の安定性と精度管理",
			],
		},
	],
};
