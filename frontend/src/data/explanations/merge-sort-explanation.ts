/**
 * src/data/explanations/merge-sort-explanation.ts
 *
 * マージソートの解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "../../components/calculator/CalculationExplanation";

/**
 * マージソートの解説データ
 * アルゴリズムの基本概念から実装まで段階的に説明
 */
export const mergeSortExplanation: ExplanationData = {
	calculationType: "merge_sort",
	title: "マージソートアルゴリズムとは？",
	overview:
		"マージソートは、分割統治法（Divide and Conquer）を使用した安定で効率的なソートアルゴリズムです。配列を半分ずつに分割し続け、単一要素になったら、ソート済みの小配列同士を順序よくマージ（結合）して元のサイズまで戻します。常にO(n log n)の時間計算量を保証し、安定ソートの特性を持つため、実用的なアプリケーションで広く使用されています。",

	sections: [
		{
			id: "divide-and-conquer-concept",
			title: "🎯 分割統治法の基本理念",
			content:
				"マージソートの核心は「分割統治法」です。大きな問題を解決可能な小さな部分問題に分割し、それぞれを独立して解決し、結果を統合して元の問題の解答を得る手法です。マージソートでは、「ソートできない大きな配列」を「必ずソートできる単一要素」まで分割し、「2つのソート済み配列のマージ」という簡単な操作で解決します。",
			importance: "high",
			examples: [
				"料理の準備：材料の下ごしらえを並行して行い、最後に組み合わせる",
				"プロジェクト管理：大きなタスクを小さなタスクに分割して実行",
				"辞書の整理：アルファベット順に分けてから、各グループ内で整理",
			],
		},

		{
			id: "divide-phase",
			title: "✂️ 分割フェーズの詳細",
			content:
				"分割フェーズでは、配列を中央で半分に分け続けます。この操作を要素が1個になるまで再帰的に実行します。分割自体は非常に高速（O(1)）で、主に中央のインデックスを計算するだけです。分割の深さはlog₂(n)となり、これがアルゴリズム全体の対数的な性能に寄与します。このフェーズでは実際のソート作業は行われません。",
			importance: "high",
			examples: [
				"ステップ1：[38,27,43,3,9,82,10] → [38,27,43] + [3,9,82,10]",
				"ステップ2：[38,27,43] → [38] + [27,43]",
				"ステップ3：[27,43] → [27] + [43]",
				"最終的に全て単一要素になるまで分割",
			],
		},

		{
			id: "conquer-phase",
			title: "🔗 統治（マージ）フェーズの詳細",
			content:
				"統治フェーズでは、分割された小配列を順序よくマージしていきます。2つのソート済み配列をマージする操作は、両方の先頭要素を比較し、小さい方を結果に追加するという単純な手順を繰り返します。この操作は線形時間O(n)で実行でき、安定性（同じ値の順序保持）も自然に保たれます。",
			importance: "high",
			examples: [
				"[27] + [43] → [27,43] （27 < 43なので順序通り）",
				"[38] + [27,43] → [27,38,43] （各要素を順次比較）",
				"最終的に [3,9,10,27,38,43,82] が完成",
			],
		},

		{
			id: "merge-operation",
			title: "⚙️ マージ操作の仕組み",
			content:
				"マージ操作は、マージソートの最も重要な部分です。2つのソート済み配列を受け取り、各配列の先頭から要素を比較して、小さい（または等しい）要素を結果配列に追加します。等しい場合は左の配列から取ることで安定性を保ちます。一方の配列が空になったら、残った配列の要素をすべて結果に追加します。",
			importance: "medium",
			examples: [
				"[3,27] と [9,43] のマージ：3<9 → [3], 27>9 → [3,9], 27<43 → [3,9,27], 残り → [3,9,27,43]",
				"安定性：[1a,3] と [1b,2] → [1a,1b,2,3] （同じ値でも順序保持）",
				"効率性：各要素を1回ずつ処理するだけでO(n)時間",
			],
		},

		{
			id: "time-complexity",
			title: "⏱️ 時間計算量の保証",
			content:
				"マージソートの最大の特徴は、入力データの状態に関係なく常にO(n log n)の時間計算量を保証することです。分割フェーズでlog n層の分割を行い、各層でO(n)時間のマージ操作を実行するため、全体でO(n log n)となります。これは理論上のソート性能の下限に近い最適な性能です。",
			formula:
				"時間計算量: O(n log n) （全ケース）<br>空間計算量: O(n)<br><br>分割層数: log₂(n)<br>各層のマージ時間: O(n)<br>総時間: O(n log n)",
			importance: "medium",
			examples: [
				"1000要素：約10,000回の操作（1000 × log₂(1000) ≈ 10,000）",
				"データの状態に無関係：ソート済み、逆順、ランダムすべて同じ性能",
				"予測可能：リアルタイムシステムでも安心して使用可能",
			],
		},

		{
			id: "stability-analysis",
			title: "🔄 安定性の保証",
			content:
				"マージソートは「安定ソート」です。同じ値を持つ要素の相対的な順序が、ソート後も保たれます。マージ操作で同じ値の要素に遭遇した場合、常に左の配列（元の順序で先に現れた要素）を優先するためです。この特性により、複数のキーでの段階的ソートや、データの一意性を保つ必要がある場合に重要な役割を果たします。",
			importance: "medium",
			examples: [
				"例：[(田中,25), (佐藤,30), (田中,20)] を年齢順ソート",
				"結果：[(田中,20), (田中,25), (佐藤,30)] （田中さんの順序保持）",
				"応用：名前順→年齢順の段階的ソートが可能",
			],
		},

		{
			id: "space-complexity",
			title: "💾 空間計算量の特性",
			content:
				"マージソートの唯一の欠点は、O(n)の追加メモリが必要なことです。マージ操作で結果を格納するための配列が必要で、再帰的な実装では各分割レベルで新しい配列を作成します。しかし、この追加メモリにより安定性とO(n log n)の性能保証が実現されているため、メモリと性能のトレードオフとして受け入れられています。",
			importance: "medium",
			examples: [
				"n=1000の配列：最大1000要素分の追加メモリ",
				"対策：インプレース実装も可能（ただし複雑）",
				"実用性：現代のコンピューターでは大きな問題にならない",
			],
		},

		{
			id: "comparison-with-others",
			title: "🆚 他のソートアルゴリズムとの比較",
			content:
				"マージソートは、他の主要なソートアルゴリズムと比較して独特の特徴を持ちます。クイックソートは平均的に高速ですが最悪ケースでO(n²)になり不安定、ヒープソートは最悪ケースでもO(n log n)ですが不安定でキャッシュ効率が悪い、マージソートは常にO(n log n)で安定という特性があります。用途に応じた使い分けが重要です。",
			importance: "high",
			examples: [
				"クイックソート：高速、不安定、最悪O(n²)、インプレース",
				"ヒープソート：O(n log n)保証、不安定、キャッシュ効率悪い",
				"マージソート：O(n log n)保証、安定、外部ソート対応",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実際の応用場面",
			content:
				"マージソートは、その安定性と性能保証により多くの実用的な場面で使用されています。Pythonのsort()関数の基礎となるTimsort、Javaのオブジェクト配列ソート、大規模データベースの外部ソート、並列処理システムでの分散ソートなどで採用されています。また、安定性が重要なアプリケーションでは第一選択となることが多いです。",
			importance: "low",
			examples: [
				"プログラミング言語：Python、JavaのオブジェクトソートAPI",
				"データベース：大容量データの外部ソート処理",
				"並列処理：MapReduceなどの分散処理フレームワーク",
			],
		},
	],
};
