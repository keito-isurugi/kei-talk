import type { ExplanationData } from "@/types/algorithm";

export const bfsExplanation: ExplanationData = {
	calculationType: "幅優先探索（BFS）",
	title: "幅優先探索（Breadth-First Search）の詳細解説",
	overview:
		"幅優先探索（BFS）は、グラフや木構造を探索する基本的なアルゴリズムの一つです。始点から近い頂点を優先的に探索し、同じ距離にある頂点をすべて訪問してから次の距離の頂点に進みます。キュー（FIFO）データ構造を使用して実装されます。",
	sections: [
		{
			id: "basic-concept",
			title: "基本概念",
			content:
				"BFSは「幅優先」という名前の通り、グラフを水平方向（幅方向）に探索します。波紋が広がるように、始点から等距離にある頂点を同時に探索していきます。この特性により、無重みグラフにおいて最短経路を保証できます。",
			importance: "high",
			examples: [
				"友達の友達を探す：まず直接の友達全員を見つけ、次に友達の友達全員を見つける",
				"迷路の最短経路：スタートから1歩で行ける場所、2歩で行ける場所...と探索",
				"ウイルスの拡散シミュレーション：感染源から同心円状に広がる様子",
			],
		},
		{
			id: "data-structure",
			title: "データ構造とアルゴリズムの流れ",
			content:
				"BFSの実装にはキュー（先入れ先出し）を使用します。訪問済みの頂点を記録するSet、探索待ちの頂点を管理するキューが必要です。",
			importance: "high",
			examples: [
				"1. 始点をキューに追加し、訪問済みとしてマーク",
				"2. キューから頂点を取り出す（dequeue）",
				"3. その頂点の未訪問の隣接頂点をすべてキューに追加（enqueue）",
				"4. キューが空になるまで2-3を繰り返す",
			],
			formula:
				"Queue: [start] → [neighbor1, neighbor2] → [n1's neighbors, n2's neighbors] → ...",
		},
		{
			id: "implementation-patterns",
			title: "実装パターン",
			content:
				"BFSには主に2つの実装パターンがあります：通常のBFS（経路を記録）とレベル別BFS（深さを記録）。用途に応じて使い分けます。",
			importance: "medium",
			examples: [
				"通常のBFS：訪問順序を記録し、経路を復元可能",
				"レベル別BFS：各頂点の始点からの距離（レベル）を記録",
				"双方向BFS：始点と終点の両方から探索し、中間で出会う（高速化技法）",
			],
		},
		{
			id: "complexity-analysis",
			title: "計算量の分析",
			content:
				"BFSの時間計算量はO(|V| + |E|)です。ここで|V|は頂点数、|E|は辺数を表します。各頂点と各辺を最大1回ずつ訪問するためです。空間計算量はO(|V|)で、最悪の場合すべての頂点がキューに入る可能性があります。",
			importance: "high",
			examples: [
				"完全グラフ：O(V²)の時間計算量（E = V(V-1)/2）",
				"木構造：O(V)の時間計算量（E = V-1）",
				"疎グラフ：O(V)に近い時間計算量",
			],
			formula: "Time: O(|V| + |E|), Space: O(|V|)",
		},
		{
			id: "shortest-path",
			title: "最短経路の保証",
			content:
				"BFSの最も重要な性質は、無重みグラフ（すべての辺の重みが等しいグラフ）において最短経路を保証することです。これは、BFSが距離の小さい頂点から順に探索するためです。",
			importance: "high",
			examples: [
				"迷路問題：各マスへの移動コストが1の場合、BFSで最短経路が求まる",
				"ソーシャルネットワーク：最小ホップ数で到達可能な経路",
				"注意：重み付きグラフではダイクストラ法などが必要",
			],
		},
		{
			id: "practical-applications",
			title: "実用的な応用分野",
			content:
				"BFSは様々な分野で活用されています。特に最短経路が重要な問題や、レベルごとの処理が必要な問題で威力を発揮します。",
			importance: "medium",
			examples: [
				"Webクローラー：ウェブサイトのリンクを幅優先で収集",
				"ゲームAI：チェスやパズルゲームの最小手数解",
				"ネットワーク分析：最短経路、到達可能性の判定",
				"画像処理：領域塗りつぶし（Flood Fill）アルゴリズム",
				"コンパイラ：依存関係の解析",
			],
		},
		{
			id: "comparison-with-dfs",
			title: "DFSとの比較",
			content:
				"BFSとDFS（深さ優先探索）は相補的な関係にあります。問題の性質によって使い分けることが重要です。",
			importance: "medium",
			examples: [
				"BFSの利点：最短経路保証、レベル順処理、完全性（解が浅い位置にある場合に有利）",
				"BFSの欠点：メモリ使用量が多い、深い解の探索に不向き",
				"DFSの利点：メモリ効率的、再帰で簡潔に実装可能",
				"DFSの欠点：最短経路を保証しない、無限ループの危険性",
			],
		},
		{
			id: "common-mistakes",
			title: "よくある間違いと注意点",
			content:
				"BFSを実装する際によく発生するミスとその対策について理解しておくことが重要です。",
			importance: "high",
			examples: [
				"訪問済みチェックのタイミング：キューに追加する時点でチェックする（取り出し時ではない）",
				"重複訪問：同じ頂点が複数回キューに入らないよう注意",
				"無限ループ：サイクルのあるグラフでは訪問済み管理が必須",
				"メモリ不足：大規模グラフでは双方向BFSなどの最適化を検討",
			],
		},
		{
			id: "optimization-techniques",
			title: "最適化技法",
			content:
				"BFSの性能を向上させるための様々な最適化技法があります。問題の規模や特性に応じて適切な技法を選択します。",
			importance: "low",
			examples: [
				"双方向BFS：始点と終点の両方から探索し、探索空間を大幅に削減",
				"並列BFS：複数のスレッドで同一レベルの頂点を並列処理",
				"ビットマスクBFS：状態を整数で表現し、メモリ使用量を削減",
				"A*アルゴリズム：ヒューリスティックを使用してBFSを高速化",
			],
		},
	],
};
