/**
 * src/data/explanations/next-permutation-explanation.ts
 *
 * next_permutation（順列全列挙）の解説データ
 * 辞書順での順列生成について学習者向けに詳解
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * next_permutation（順列全列挙）の解説データ
 * アルゴリズムの原理から実用的応用まで段階的に説明
 */
export const nextPermutationExplanation: ExplanationData = {
	calculationType: "next_permutation",
	title: "next_permutation（順列全列挙）とは？",
	overview:
		"next_permutation（順列全列挙）は、辞書順で次の順列を効率的に生成する標準的なアルゴリズムです。C++のstd::next_permutationと同等の機能を提供し、4つのステップで最小限の変更により次の順列を生成します。全ての順列を系統的に列挙でき、平均的にはO(1)時間での実行が可能です。組み合わせ最適化、暗号学、グラフ理論など幅広い分野で活用される重要なアルゴリズムです。",

	sections: [
		{
			id: "lexicographic-order",
			title: "📚 辞書順の概念",
			content:
				"辞書順（Lexicographic Order）は、辞書で単語が並んでいる順序と同じ原理で順列を並べる方法です。左から比較して最初に異なる位置の要素で大小を決定します。例えば[1,2,3]は[1,3,2]より小さく、[2,1,3]より小さくなります。この順序により、全ての順列を一意の順番で並べることができ、「次の順列」を明確に定義できます。",
			importance: "high",
			examples: [
				"[1,2,3] < [1,2,4] < [1,3,2] < [2,1,3]",
				"最初の順列: [1,2,3]（昇順）",
				"最後の順列: [3,2,1]（降順）",
				"位置0で比較 → 位置1で比較 → ...",
			],
		},

		{
			id: "algorithm-steps",
			title: "🔄 4ステップアルゴリズム",
			content:
				"next_permutationアルゴリズムは4つの明確なステップで構成されます。①右から最初の昇順位置（ピボット）を発見、②ピボットより大きい最小の要素を発見、③両者を交換、④ピボット以降を昇順に並び替え。この手順により、現在の順列から辞書順で次に大きい順列を効率的に生成できます。各ステップは論理的に必要で、省略できません。",
			importance: "high",
			examples: [
				"[1,2,4,3] → ピボット位置1（値2）",
				"交換相手位置2（値4）",
				"交換後[1,4,2,3] → 位置2以降反転",
				"結果[1,4,3,2]（次の順列）",
			],
		},

		{
			id: "efficiency-analysis",
			title: "⚡ 効率性の分析",
			content:
				"next_permutationの時間計算量は平均的にO(1)、最悪の場合でもO(n)です。多くの場合は末尾近くの小さな交換と反転で完了するため、非常に効率的です。全n!個の順列を生成する場合の総計算量はO(n! × n)となりますが、各順列生成は高速です。空間計算量はO(1)のin-place操作で、メモリ効率も優秀です。",
			formula:
				"next_permutationの計算量:<br>時間計算量: 平均O(1), 最悪O(n)<br>空間計算量: O(1) (in-place操作)<br><br>全順列生成:<br>総時間: O(n! × n)<br>1順列あたり: 平均O(1)",
			importance: "high",
			examples: [
				"末尾交換: [1,2,3,4] → [1,2,4,3] (O(1))",
				"部分反転: [1,3,4,2] → [1,4,2,3] (O(k))",
				"最悪ケース: [4,3,2,1] → [1,2,3,4] (O(n))",
				"平均性能: ほとんどの場合でO(1)",
			],
		},

		{
			id: "implementation-details",
			title: "💻 実装の詳細",
			content:
				"正確な実装には細かな注意が必要です。ピボット探索では配列の右端から左に向かって昇順位置を探し、交換相手探索ではピボットより大きい最小値を見つけます。境界条件（最後の順列の判定）、インデックスの範囲チェック、反転処理の正確な実装が重要です。これらの詳細を正しく実装することで、確実に動作するアルゴリズムを作成できます。",
			importance: "medium",
			examples: [
				"ピボット探索: i>=0 && arr[i]>=arr[i+1]",
				"交換相手探索: arr[j] <= arr[i]",
				"境界チェック: i<0で最後の順列判定",
				"反転処理: left<rightの条件で要素交換",
			],
		},

		{
			id: "mathematical-foundation",
			title: "🔢 数学的基盤",
			content:
				"next_permutationは順列群の数学的性質に基づいています。順列は群を成し、辞書順により全順序が定義されます。順列のランク（辞書順での位置）は階乗進法で表現でき、k番目の順列を直接構築することも可能です。逆順列、順列の合成、周期性などの概念を理解することで、より深い応用が可能になります。",
			importance: "low",
			examples: [
				"順列ランク: [2,1,4,3]は辞書順で6番目",
				"階乗進法: 23 = 3×3! + 5×2! + 1×1! + 0×0!",
				"逆順列: 順列の逆写像",
				"順列合成: 関数としての順列の合成",
			],
		},

		{
			id: "combinatorial-applications",
			title: "🎯 組み合わせ論的応用",
			content:
				"next_permutationは組み合わせ最適化問題で重要な役割を果たします。巡回セールスマン問題の厳密解法、スケジューリング問題の全解探索、組み合わせ設計の生成などで活用されます。全ての順列を系統的に列挙することで、問題の全解空間を網羅的に探索でき、小〜中規模の問題では確実な最適解を発見できます。",
			importance: "medium",
			examples: [
				"TSP: 都市訪問順序の全探索",
				"スケジューリング: タスク実行順序の最適化",
				"組み合わせ設計: 対称性を持つ配置問題",
				"グラフ理論: 頂点の順序づけ問題",
			],
		},

		{
			id: "cryptographic-uses",
			title: "🔐 暗号学での応用",
			content:
				"暗号学においてnext_permutationは鍵空間の探索や置換暗号の分析で使用されます。順列は置換暗号の基盤であり、全ての可能な置換を系統的に生成することで暗号の強度分析や鍵復元攻撃が可能です。また、乱数生成器の設計や暗号アルゴリズムのテストにも活用され、セキュリティ分野での重要性が高まっています。",
			importance: "low",
			examples: [
				"置換暗号: アルファベットの並び替え",
				"鍵空間探索: 全可能鍵の系統的探索",
				"暗号強度分析: 置換パターンの評価",
				"乱数テスト: 順列の統計的性質検証",
			],
		},

		{
			id: "performance-optimization",
			title: "🚀 性能最適化",
			content:
				"next_permutationの性能は実装の工夫により向上できます。早期終了による不要な処理の回避、キャッシュ効率を考慮したメモリアクセス、分岐予測しやすい条件分岐の設計などが効果的です。また、特定の問題に特化した最適化や、並列処理による高速化も可能です。大規模な順列生成では、これらの最適化が実行時間に大きく影響します。",
			importance: "low",
			examples: [
				"早期終了: 条件達成時の即座停止",
				"キャッシュ最適化: 連続メモリアクセス",
				"分岐最適化: 予測しやすい条件",
				"並列処理: 複数順列の同時生成",
			],
		},

		{
			id: "related-algorithms",
			title: "🔗 関連アルゴリズム",
			content:
				"next_permutationには多くの関連アルゴリズムがあります。prev_permutation（前の順列）、next_combination（次の組み合わせ）、Johnson-Trotterアルゴリズム（隣接交換による順列生成）、Heap's algorithm（全順列の効率的生成）などです。これらのアルゴリズムを理解することで、様々な組み合わせ論的問題に対応でき、問題に最適な手法を選択できます。",
			importance: "low",
			examples: [
				"prev_permutation: 前の辞書順順列",
				"next_combination: 組み合わせの次要素",
				"Johnson-Trotter: 隣接交換での生成",
				"Heap's algorithm: 最小交換での全生成",
			],
		},

		{
			id: "learning-strategy",
			title: "📈 効果的な学習戦略",
			content:
				"next_permutationの習得は、まず手作業での順列生成から始めて、アルゴリズムの各ステップを理解し、実装練習を積むのが効果的です。小さな例（3〜4要素）で手計算を行い、各ステップの必要性を確認します。その後、実装を通じて境界条件や特殊ケースの処理を学び、最終的には応用問題での活用まで習得します。理論と実践のバランスが重要です。",
			importance: "low",
			examples: [
				"手計算: [1,2,3]から全順列を手動生成",
				"ステップ理解: 各段階の論理的必要性",
				"実装練習: 境界条件と特殊ケース",
				"応用練習: 組み合わせ最適化問題",
			],
		},
	],
};
