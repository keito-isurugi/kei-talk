/**
 * src/data/explanations/quick-sort-explanation.ts
 *
 * クイックソートの解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "../../components/calculator/CalculationExplanation";

/**
 * クイックソートの解説データ
 * アルゴリズムの基本概念から実装まで段階的に説明
 */
export const quickSortExplanation: ExplanationData = {
	calculationType: "quick_sort",
	title: "クイックソートアルゴリズムとは？",
	overview:
		"クイックソートは、分割統治法（Divide and Conquer）を使用した高速なソートアルゴリズムです。配列からピボット（基準要素）を選び、ピボットより小さい要素を左、大きい要素を右に分割し、各部分を再帰的にソートします。平均的にO(n log n)の性能を持ち、多くのプログラミング言語の標準ライブラリで採用されている実用的なアルゴリズムです。",

	sections: [
		{
			id: "divide-and-conquer",
			title: "🎯 分割統治法の基本概念",
			content:
				"クイックソートの核心は「分割統治法」です。これは大きな問題を小さな問題に分割し、それぞれを解決して結果を組み合わせる手法です。クイックソートでは、ピボットを基準に配列を「小さい要素」と「大きい要素」に分割し、各部分を独立してソートします。分割された各部分が小さくなるほど、ソートは簡単になります。",
			importance: "high",
			examples: [
				"図書館の本の整理：ジャンル別に分けてから、各ジャンル内でソート",
				"会社の組織：部門別に分けてから、各部門内で役職順に整理",
				"ファイル整理：フォルダ別に分けてから、各フォルダ内で名前順にソート",
			],
		},

		{
			id: "pivot-concept",
			title: "🎪 ピボットの役割と重要性",
			content:
				"ピボット（pivot）は「回転軸」という意味で、クイックソートでは分割の基準となる要素です。ピボットを選んだ後、配列をピボット以下とピボット超過の2つのグループに分けます。ピボットは最終的に正しい位置に配置され、それより小さい要素は左、大きい要素は右に来ます。ピボットの選択戦略によってアルゴリズムの性能が大きく変わります。",
			importance: "high",
			examples: [
				"天秤の支点：重さを比較して左右に分ける基準点",
				"体重測定の基準値：基準より軽い・重いグループに分類",
				"年齢での分類：特定の年齢を基準に上下のグループに分ける",
			],
		},

		{
			id: "algorithm-steps",
			title: "📝 アルゴリズムの実行手順",
			content:
				"クイックソートは以下の手順を再帰的に実行します：1) 配列からピボットを選択、2) パーティション操作でピボット以下を左、超過を右に分割、3) ピボットを正しい位置に配置、4) 左の部分配列に対して再帰的にクイックソート、5) 右の部分配列に対して再帰的にクイックソート。ベースケース（要素数1以下）で再帰を終了します。",
			importance: "high",
			examples: [
				"ステップ1：[3,6,8,10,1,2,1] → ピボット1を選択",
				"ステップ2：[1,1,2] + [3] + [6,8,10] に分割",
				"ステップ3：左右の部分配列を再帰的にソート",
				"ステップ4：結果を統合して完成",
			],
		},

		{
			id: "partition-process",
			title: "🔄 パーティション操作の詳細",
			content:
				"パーティション操作は、クイックソートの核心部分です。選択したピボットを基準に、配列を2つの部分に分割します。一般的には、左から順に要素を調べ、ピボット以下の要素を左側に、ピボット超過の要素を右側に集めます。この操作により、ピボットが最終的な正しい位置に配置され、左右の相対的な順序が確定します。",
			importance: "medium",
			examples: [
				"2つのバケツに分類：小さいボール用と大きいボール用",
				"学生の身長順：基準身長より低い・高いグループに分ける",
				"商品の価格分類：予算以下・予算超過の2つのカテゴリ",
			],
		},

		{
			id: "time-complexity",
			title: "⏱️ 時間計算量の分析",
			content:
				"クイックソートの時間計算量は、ピボットの選択によって大きく変わります。最良・平均ケースではO(n log n)ですが、最悪ケースではO(n²)になります。最悪ケースは、毎回最小値または最大値をピボットに選んでしまい、分割が全く均等にならない場合です。しかし、ランダムピボットや中央値選択により、実用的にはO(n log n)の性能を期待できます。",
			formula:
				"時間計算量: O(n log n) ～ O(n²)<br>空間計算量: O(log n)<br><br>最良ケース: O(n log n) 分割が均等<br>平均ケース: O(n log n) ランダムなデータ<br>最悪ケース: O(n²) 分割が偏る",
			importance: "medium",
			examples: [
				"バランス良い分割：各段階で半分ずつに分かれる → O(n log n)",
				"偏った分割：毎回1要素と残り全部に分かれる → O(n²)",
				"ランダムピボット：統計的にO(n log n)の性能を維持",
			],
		},

		{
			id: "pivot-strategies",
			title: "🎲 ピボット選択戦略",
			content:
				"ピボットの選択戦略は、クイックソートの性能を左右する重要な要素です。先頭要素選択は実装が簡単ですが、ソート済み配列で性能が劣化します。末尾要素選択も同様の特性を持ちます。中央要素選択は、ソート済み配列でもバランスの取れた分割を提供します。ランダム要素選択は、理論的に最も安定した性能を期待できます。",
			importance: "high",
			examples: [
				"先頭要素：実装簡単、ソート済みデータで劣化",
				"末尾要素：一般的、先頭と同様の特性",
				"中央要素：バランス重視、多くの実装で採用",
				"ランダム要素：理論的に最適、予測不可能な性能",
			],
		},

		{
			id: "advantages-disadvantages",
			title: "✅ 利点と注意点",
			content:
				"クイックソートの主な利点は、平均的に高速で実用性が高いこと、インプレースソートでメモリ効率が良いこと、キャッシュ効率が良いことです。一方、最悪ケースでO(n²)になること、不安定ソートであること、再帰実装でスタックオーバーフローの可能性があることが注意点です。これらの特性を理解して適切に使用することが重要です。",
			importance: "medium",
			examples: [
				"利点：高速、メモリ効率良い、実用的",
				"注意点：最悪ケース劣化、不安定、スタック使用",
				"対策：ピボット戦略改善、ハイブリッド実装、末尾再帰最適化",
			],
		},

		{
			id: "comparison-with-others",
			title: "🆚 他のソートアルゴリズムとの比較",
			content:
				"O(n log n)アルゴリズムの中で、クイックソートは実用性が最も高いとされています。マージソートは安定で最悪ケースでもO(n log n)ですが、追加メモリが必要です。ヒープソートも最悪ケースでO(n log n)ですが、キャッシュ効率が劣ります。クイックソートは、平均的な性能、メモリ効率、キャッシュ効率のバランスが優れているため、多くの標準ライブラリで採用されています。",
			importance: "high",
			examples: [
				"マージソート：安定、O(n log n)保証、追加メモリ必要",
				"ヒープソート：O(n log n)保証、キャッシュ効率劣る",
				"クイックソート：実用的、高速、メモリ効率良い",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実際の応用場面",
			content:
				"クイックソートは、現代のソフトウェア開発で最も広く使用されているソートアルゴリズムです。C++のstd::sort、JavaのArrays.sort（プリミティブ型）、.NETのArray.Sortなど、多くの標準ライブラリが採用しています。また、データベースの内部ソート、大規模データ処理、ゲーム開発でのスコアランキングなど、様々な場面で使用されています。",
			importance: "low",
			examples: [
				"標準ライブラリ：C++、Java、.NETの基本ソート関数",
				"データベース：内部的なレコードソート処理",
				"ビッグデータ：MapReduceなどの分散処理フレームワーク",
			],
		},
	],
};
