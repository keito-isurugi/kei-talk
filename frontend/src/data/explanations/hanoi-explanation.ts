/**
 * src/data/explanations/hanoi-explanation.ts
 *
 * ハノイの塔（再帰）の解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * ハノイの塔（再帰）の解説データ
 * 再帰アルゴリズムの応用例として分割統治法の理解を深める
 */
export const hanoiExplanation: ExplanationData = {
	calculationType: "hanoi_recursive",
	title: "ハノイの塔（再帰）アルゴリズムとは？",
	overview:
		"ハノイの塔は、3本の杭（A、B、C）と異なるサイズのn枚の円盤を使った古典的なパズルです。全ての円盤を杭Aから杭Cに移動するのが目標で、「大きな円盤を小さな円盤の上に置けない」「1回に1枚しか移動できない」というルールがあります。この問題は再帰的な分割統治法で美しく解けるため、再帰アルゴリズムの教育例として非常に人気があります。最小移動回数は2^n - 1回で、指数的な複雑さを持ちながらも論理的な美しさを兼ね備えています。",

	sections: [
		{
			id: "hanoi-rules",
			title: "🏗️ ハノイの塔のルール",
			content:
				"ハノイの塔は非常にシンプルなルールで構成されています。3本の杭（通常A、B、Cと呼ばれる）があり、最初は全ての円盤が杭Aに大きい順に積まれています。目標は全ての円盤を杭Cに移動することです。移動時のルールは、①1回につき1枚の円盤しか移動できない、②大きな円盤を小さな円盤の上に置けない、という2つだけです。この単純なルールから生まれる複雑な移動パターンが、このパズルの魅力です。",
			importance: "high",
			examples: [
				"初期状態: 杭Aに全円盤（大→小の順）",
				"目標状態: 杭Cに全円盤（大→小の順）",
				"制約1: 1回に1枚しか移動できない",
				"制約2: 大きい円盤を小さい円盤の上に置けない",
				"杭B: 補助的な作業スペースとして使用",
			],
		},

		{
			id: "recursive-thinking",
			title: "🧠 再帰的思考の適用",
			content:
				"ハノイの塔の解法は再帰的思考の典型例です。n枚の円盤を移動する問題を、「上のn-1枚を補助杭に移動」→「最下段の円盤を目標杭に移動」→「補助杭のn-1枚を目標杭に移動」という3つのサブ問題に分解します。このサブ問題も同じ構造を持つため、再帰的に解決できます。ベースケースは1枚の円盤の移動で、これは直接実行可能です。この分割統治の考え方は、複雑な問題を小さな同種の問題に分解する重要な思考パターンです。",
			importance: "high",
			examples: [
				"n枚の問題を3つのサブ問題に分解：",
				"1. 上のn-1枚を補助杭に移動",
				"2. 最下段（最大）の円盤を目標杭に移動",
				"3. 補助杭のn-1枚を目標杭に移動",
				"ベースケース: 1枚なら直接移動",
			],
		},

		{
			id: "divide-conquer-strategy",
			title: "🔄 分割統治法の実装",
			content:
				"ハノイの塔は分割統治法の美しい実装例です。hanoi(n, from, to, aux)という関数で、n枚の円盤をfrom杭からto杭に、aux杭を補助として移動します。実装は、①hanoi(n-1, from, aux, to)で上のn-1枚を補助杭に移動、②最下段の円盤をfromからtoに直接移動、③hanoi(n-1, aux, to, from)で補助杭からto杭に移動、という3ステップです。各再帰呼び出しで問題サイズが1減り、最終的に1枚の移動（ベースケース）まで分解されます。",
			importance: "high",
			examples: [
				"関数定義: hanoi(n, from, to, aux)",
				"ステップ1: hanoi(n-1, from, aux, to)",
				"ステップ2: move disk from → to (直接移動)",
				"ステップ3: hanoi(n-1, aux, to, from)",
				"ベースケース: n=1なら直接移動",
			],
		},

		{
			id: "exponential-complexity",
			title: "📈 指数的計算量の理解",
			content:
				"ハノイの塔の最小移動回数は2^n - 1回で、これは指数的複雑さの典型例です。n=1で1回、n=2で3回、n=3で7回、n=4で15回と、円盤が1枚増えるたびに移動回数が約2倍になります。この指数的増加により、n=20で約100万回、n=30で約10億回の移動が必要になります。フィボナッチ数列と同様に指数的複雑さを持ちますが、ハノイの塔の場合は最適解が存在し、これ以上短縮できない理論的下限を表しています。",
			formula:
				"移動回数: 2^n - 1<br>時間計算量: O(2^n)<br>空間計算量: O(n) （再帰の深さ）<br><br>具体例:<br>n=3: 2³-1 = 7回<br>n=10: 2¹⁰-1 = 1,023回<br>n=20: 2²⁰-1 = 1,048,575回",
			importance: "medium",
			examples: [
				"n=1: 1回移動",
				"n=2: 3回移動",
				"n=3: 7回移動",
				"n=4: 15回移動",
				"n=10: 1,023回移動",
				"n=64: 約1844京回移動（宇宙の年齢を超える）",
			],
		},

		{
			id: "visual-understanding",
			title: "👀 視覚的理解の重要性",
			content:
				"ハノイの塔は視覚的な理解が特に重要なアルゴリズムです。円盤の移動パターンを目で追うことで、再帰の動作メカニズムが直感的に理解できます。各ステップで「なぜその移動が必要なのか」「どのように全体の解決に貢献するのか」を視覚的に確認することで、抽象的な再帰の概念が具体的になります。また、移動の美しいパターン（二進数との関係など）も視覚化によって発見できます。プログラミング学習において、アルゴリズムの動作を「見る」ことの教育的価値を示す優秀な例です。",
			importance: "medium",
			examples: [
				"円盤の移動を順次表示",
				"3つの杭の状態変化を追跡",
				"再帰呼び出しの深度を可視化",
				"移動回数のカウントアップ",
				"最適解パスの確認",
			],
		},

		{
			id: "recursive-vs-iterative",
			title: "🔄 再帰実装 vs 反復実装",
			content:
				"ハノイの塔は再帰実装が非常に自然で美しいアルゴリズムですが、反復実装も存在します。再帰実装は問題の本質を直接的に表現し、コードが短く理解しやすいです。一方、反復実装はスタックを明示的に管理し、深い再帰によるスタックオーバーフローを回避できます。教育的には再帰実装が分割統治の理解に適していますが、実用的には大きなnに対して反復実装が安全です。両方の実装を比較することで、再帰とループの特性と使い分けを学習できます。",
			importance: "medium",
			examples: [
				"再帰: 自然で直感的、数学的定義に忠実",
				"反復: スタック管理が明示的、メモリ効率",
				"再帰の利点: コードの簡潔性、理解しやすさ",
				"反復の利点: スタックオーバーフロー回避",
				"教育用途: 再帰実装が概念理解に最適",
			],
		},

		{
			id: "mathematical-insights",
			title: "🔢 数学的洞察",
			content:
				"ハノイの塔には多くの数学的性質が隠されています。移動回数2^n - 1は、n個の円盤のすべての可能な組み合わせから初期状態を引いた数です。また、最小円盤（円盤1）は必ず一定のパターンで移動し、円盤kは2^(k-1)回移動します。移動順序は二進数のカウンターと深い関係があり、Gray符号というエラー訂正符号とも関連します。これらの数学的性質は、アルゴリズムが単なる手順ではなく、深い数学的構造を持つことを示しています。",
			importance: "low",
			examples: [
				"総移動回数: 2^n - 1 = 全組み合わせ - 初期状態",
				"円盤k の移動回数: 2^(k-1)回",
				"最小円盤の移動パターン: A→C→B→A→C→B...",
				"二進数カウンターとの対応関係",
				"Gray符号との関連性",
			],
		},

		{
			id: "real-world-applications",
			title: "🌍 実世界での応用",
			content:
				"ハノイの塔の原理は、コンピュータサイエンスの様々な分野で応用されています。バックアップシステムでのデータ移動戦略、コンパイラの最適化、データ構造の操作、並列処理でのタスク分散などで類似のパターンが使用されます。また、プロジェクト管理における依存関係の解決や、化学反応の手順最適化など、分割統治法が有効な多くの実問題の基礎となっています。教育的には、再帰的思考、問題分解、最適化理論の理解に役立ちます。",
			importance: "low",
			examples: [
				"バックアップシステム: データ移動の最適化",
				"コンパイラ最適化: 処理順序の決定",
				"プロジェクト管理: 依存関係の解決",
				"並列処理: タスクの分散・統合",
				"教育分野: 再帰思考の訓練",
			],
		},
	],
};
