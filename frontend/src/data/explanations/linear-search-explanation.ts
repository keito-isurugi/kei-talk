/**
 * src/data/explanations/linear-search-explanation.ts
 *
 * 線形探索の解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "../../components/calculator/CalculationExplanation";

/**
 * 線形探索の解説データ
 * アルゴリズムの基本概念から実装まで段階的に説明
 */
export const linearSearchExplanation: ExplanationData = {
	calculationType: "linear_search",
	title: "線形探索アルゴリズムとは？",
	overview:
		"線形探索は、配列の先頭から順番に要素をチェックして目標値を探すシンプルな探索アルゴリズムです。「逐次探索」とも呼ばれ、最も基本的で理解しやすい探索方法です。ソートされていない配列でも使用でき、実装が簡単なため、小規模なデータや特別な条件がない場合によく使用されます。",

	sections: [
		{
			id: "basic-concept",
			title: "🔍 基本的な考え方",
			content:
				"線形探索の考え方は、本棚で特定の本を探すときと同じです。本が整理されていない本棚では、最初の本から順番に1冊ずつタイトルを確認していくしかありません。目的の本が見つかるまで、または全ての本をチェックし終わるまで、この作業を続けます。",
			importance: "high",
			examples: [
				"本棚での本探し：左端から順番にタイトルを確認",
				"名簿での名前探し：上から順番に名前をチェック",
				"引き出しでの物探し：手前から順番に中身を確認",
			],
		},

		{
			id: "algorithm-steps",
			title: "📝 アルゴリズムの手順",
			content:
				"線形探索は以下の単純な手順を繰り返します：1) 配列の最初の要素から開始、2) 現在の要素と目標値を比較、3) 一致すれば探索終了、4) 一致しなければ次の要素へ移動、5) 配列の最後まで到達したら「見つからない」を報告。この手順の単純さが線形探索の最大の特徴です。",
			importance: "high",
			examples: [
				"ステップ1：[3,1,4,1,5] で 4 を探す",
				"ステップ2：3 ≠ 4 → 次へ",
				"ステップ3：1 ≠ 4 → 次へ",
				"ステップ4：4 = 4 → 発見！",
			],
		},

		{
			id: "time-complexity",
			title: "⏱️ 時間計算量の理解",
			content:
				"線形探索の時間計算量は O(n) です。これは配列の要素数に比例して実行時間が増加することを意味します。最良の場合（最初に見つかる）はO(1)、平均的な場合は O(n/2)、最悪の場合（最後にある、または見つからない）は O(n) となります。",
			formula:
				"時間計算量: O(n)<br>空間計算量: O(1)<br><br>最良の場合: O(1) （最初に発見）<br>平均の場合: O(n/2)<br>最悪の場合: O(n) （最後or未発見）",
			importance: "medium",
			examples: [
				"100個の要素：最悪100回、平均50回の比較",
				"1000個の要素：最悪1000回、平均500回の比較",
				"要素数が2倍になると、実行時間も約2倍",
			],
		},

		{
			id: "advantages",
			title: "✅ 線形探索の利点",
			content:
				"線形探索には多くの利点があります。実装が非常にシンプルで理解しやすく、デバッグも容易です。ソートされていない配列でも使用でき、配列の順序を変更する必要がありません。また、メモリ使用量が少なく（O(1)の空間計算量）、小規模なデータセットでは十分に実用的です。",
			importance: "medium",
			examples: [
				"実装の簡単さ：数行のコードで記述可能",
				"前処理不要：ソートなどの準備作業が不要",
				"メモリ効率：追加のメモリをほとんど使用しない",
			],
		},

		{
			id: "binary-search-comparison",
			title: "🆚 二分探索との比較",
			content:
				"線形探索と二分探索の使い分けは重要です。線形探索は O(n) でソート不要ですが、二分探索は O(log n) でソート済み配列が必要です。データが少ない場合やソートのコストが高い場合は線形探索が、大量のソート済みデータでは二分探索が適しています。",
			importance: "high",
			examples: [
				"小規模データ（~100要素）：線形探索が実用的",
				"大規模データ（1000要素以上）：二分探索が効率的",
				"頻繁な挿入・削除：線形探索が柔軟",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実際の応用例",
			content:
				"線形探索は身近なところで多く使用されています。小規模なリストでの検索、設定ファイルでの値検索、ログファイルでの特定レコード検索、メニューシステムでの選択肢検索など、データ量が限られている場面では線形探索が最適な選択となることが多いです。",
			importance: "medium",
			examples: [
				"Webページ：ナビゲーションメニューでの項目検索",
				"設定画面：オプション一覧からの項目選択",
				"ファイル検索：小規模フォルダ内のファイル探索",
			],
		},

		{
			id: "implementation-variations",
			title: "🔧 実装のバリエーション",
			content:
				"線形探索には様々な実装パターンがあります。基本的な要素検索、最初に見つかった位置の返却、全ての一致位置の返却、条件に合う要素の検索、カウント機能付き検索など、用途に応じて様々な形に拡張できます。この柔軟性も線形探索の魅力の一つです。",
			importance: "low",
			examples: [
				"全件検索：一致する全ての要素を取得",
				"条件検索：特定の条件を満たす要素を検索",
				"カウント機能：一致した要素の個数を返却",
			],
		},
	],
};
