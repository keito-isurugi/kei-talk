/**
 * src/data/explanations/union-find-explanation.ts
 *
 * Union-Find（素集合データ構造）の解説データ
 * 互いに素な集合の効率的な管理と最適化技法を包括的に説明
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * Union-Find（素集合データ構造）の解説データ
 * 基本概念から高度な最適化まで段階的に説明
 */
export const unionFindExplanation: ExplanationData = {
	calculationType: "union_find",
	title: "Union-Find（素集合データ構造）とは？",
	overview:
		"Union-Find（Disjoint Set Union, DSU）は、互いに素な集合の効率的な管理を行うデータ構造です。「どの要素がどの集合に属するか」を高速に判定し、異なる集合を効率的に合併することができます。パス圧縮とランクによる合併という2つの最適化により、実用的にはほぼ定数時間での操作を実現し、グラフの連結性判定、クラスカル法による最小全域木構築、画像処理での連結成分ラベリングなど、幅広い分野で応用されています。理論的には逆アッカーマン関数α(n)の時間計算量を持ち、非常に効率的なデータ構造として知られています。",

	sections: [
		{
			id: "basic-concepts",
			title: "🌳 基本概念と森データ構造",
			content:
				"Union-Findは、互いに素な集合を森（Forest）データ構造で管理します。各集合を木構造で表現し、木の根（ルート）をその集合の代表元とします。同じ代表元を持つ要素は同じ集合に属することになります。初期状態では、各要素が独立した集合（単一ノードの木）として存在し、Union操作により異なる集合が合併され、Find操作により要素の代表元を検索します。この実装では、各要素は親へのポインタ（配列のインデックス）を持ち、代表元は自分自身を親とします。森構造により、複数の独立した集合を効率的に管理でき、動的な集合の変化に柔軟に対応できます。木の高さを低く保つことが性能向上の鍵となります。",
			importance: "high",
			examples: [
				"初期状態: {0}, {1}, {2}, {3} - 4つの独立した集合",
				"Union(0,1)後: {0,1}, {2}, {3} - 2つの要素が合併",
				"代表元: 各集合の根ノードが代表元として機能",
				"森構造: 複数の木が並立して存在",
			],
			formula:
				"基本操作:<br>• MakeSet(x): 要素xの新しい集合を作成<br>• Find(x): 要素xの代表元を検索<br>• Union(x,y): 要素xとyの集合を合併<br>• Connected(x,y): xとyが同じ集合か判定<br><br>親子関係:<br>parent[x] = x ⟺ xは代表元",
		},

		{
			id: "path-compression",
			title: "⚡ パス圧縮最適化",
			content:
				"パス圧縮（Path Compression）は、Find操作の性能を劇的に向上させる最適化技法です。通常のFind操作では、要素から代表元まで親を辿って移動しますが、パス圧縮では経路上の全ての要素を直接代表元に接続し直します。これにより、次回以降のFind操作で同じ経路の要素にアクセスする際の計算量が大幅に削減されます。パス圧縮は再帰的または反復的に実装でき、Find操作の償却時間計算量をO(α(n))まで改善します。重要な点は、パス圧縮により木の構造は変化しますが、集合の関係は保たれることです。この最適化により、頻繁にアクセスされる要素ほど代表元に近くなり、全体的な性能が向上します。",
			importance: "high",
			examples: [
				"圧縮前: 4→3→2→1→0（深度4）",
				"圧縮後: 4→0, 3→0, 2→0, 1→0（深度1）",
				"効果: 次回Find時の計算量が大幅削減",
				"不変性: 集合の関係は変化しない",
			],
			formula:
				"パス圧縮実装:<br>function find(x):<br>&nbsp;&nbsp;if parent[x] ≠ x:<br>&nbsp;&nbsp;&nbsp;&nbsp;parent[x] = find(parent[x])  // 再帰的圧縮<br>&nbsp;&nbsp;return parent[x]<br><br>効果: O(log n) → O(α(n))",
		},

		{
			id: "union-by-rank",
			title: "🏗️ ランクによる合併最適化",
			content:
				"ランクによる合併（Union by Rank）は、木の高さを最小限に抑える最適化技法です。各ノードにランク（木の高さの上界）を保持し、Union操作時にランクの小さい木をランクの大きい木に接続します。ランクが同じ場合は、一方を他方に接続してランクを1増加させます。この戦略により、木の高さがO(log n)に制限され、Find操作の最悪時間計算量が改善されます。ランクは実際の高さの上界であり、パス圧縮により実際の高さは変化してもランクは更新されません。これは、ランクの厳密な管理よりも実装の簡潔性を優先するためです。ランクによる合併とパス圧縮を組み合わせることで、理論的に最適な性能を実現できます。",
			importance: "high",
			examples: [
				"小さい木→大きい木: バランスの維持",
				"ランク管理: 高さの上界を保持",
				"同ランク合併: 一方のランクを増加",
				"高さ制限: 最大O(log n)に抑制",
			],
			formula:
				"ランク合併実装:<br>function union(x, y):<br>&nbsp;&nbsp;rootX = find(x)<br>&nbsp;&nbsp;rootY = find(y)<br>&nbsp;&nbsp;if rank[rootX] < rank[rootY]:<br>&nbsp;&nbsp;&nbsp;&nbsp;parent[rootX] = rootY<br>&nbsp;&nbsp;elif rank[rootX] > rank[rootY]:<br>&nbsp;&nbsp;&nbsp;&nbsp;parent[rootY] = rootX<br>&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;parent[rootY] = rootX<br>&nbsp;&nbsp;&nbsp;&nbsp;rank[rootX] += 1",
		},

		{
			id: "ackermann-analysis",
			title: "📊 逆アッカーマン関数と計算量解析",
			content:
				"Union-Findの時間計算量は、逆アッカーマン関数α(n)で表されます。アッカーマン関数A(m,n)は非常に急速に増加する関数で、その逆関数α(n)は極めてゆっくりと増加します。実用的な範囲（n ≤ 2^65536）では、α(n) ≤ 4となり、ほぼ定数と見なせます。この解析は、Union-Findが理論的に最適なオンラインアルゴリズムであることを示しています。m回のFind/Union操作の総時間計算量はO(m α(n))となり、単一操作の償却時間計算量はO(α(n))です。この結果は、Tarjanによる詳細な解析により証明されており、パス圧縮とランク合併の両方が必要であることが示されています。実用的には、この性能はほぼ線形時間と同等であり、多くのアプリケーションで優秀な性能を発揮します。",
			importance: "medium",
			examples: [
				"α(1) = 1, α(3) = 2, α(7) = 3, α(2047) = 4",
				"α(2^65536) = 5（理論上の限界）",
				"実用範囲: n ≤ 10^9でα(n) ≤ 4",
				"償却解析: m操作でO(m α(n))",
			],
			formula:
				"アッカーマン関数:<br>A(0,n) = n+1<br>A(m+1,0) = A(m,1)<br>A(m+1,n+1) = A(m,A(m+1,n))<br><br>逆関数:<br>α(n) = min{k : A(k,k) ≥ n}<br><br>時間計算量: O(m α(n))",
		},

		{
			id: "graph-connectivity",
			title: "🗺️ グラフの連結性判定",
			content:
				"Union-Findはグラフの連結性判定において重要な役割を果たします。無向グラフの連結成分を効率的に管理し、動的な辺の追加に対して連結性の変化を高速に更新できます。オフライン問題では、全ての辺を事前に知っている場合にUnion-Findを使用して連結成分を構築できます。オンライン問題では、辺が逐次追加される状況で、リアルタイムに連結性を判定できます。また、2つの頂点が連結しているかの判定、連結成分の数の取得、各連結成分のサイズ計算なども効率的に実行できます。ネットワークの信頼性解析、ソーシャルネットワークのコミュニティ検出、回路設計での導通確認など、様々な分野で応用されています。特に、動的グラフでの連結性維持は、Union-Findの得意とする領域です。",
			importance: "medium",
			examples: [
				"連結判定: Union-Find.connected(u, v)",
				"成分数: 独立した代表元の数",
				"成分サイズ: 各代表元の管理する要素数",
				"動的更新: 辺追加時のリアルタイム更新",
			],
		},

		{
			id: "kruskals-algorithm",
			title: "🌲 クラスカル法での最小全域木構築",
			content:
				"クラスカル法は、Union-Findを中核として使用する最小全域木構築アルゴリズムです。全ての辺を重み順にソートし、軽い辺から順に検討して、閉路を作らない辺のみを採用します。閉路判定にUnion-Findを使用し、辺の両端点が既に連結されている場合（同じ集合に属する場合）はその辺を採用しません。このアルゴリズムの時間計算量は、ソート部分のO(E log E)が支配的で、Union-Find部分はO(E α(V))となります。クラスカル法は、グラフが疎（辺の数が少ない）場合に特に効率的で、プリム法と並んで実用的な最小全域木アルゴリズムです。ネットワーク設計、配線最適化、クラスタリングなどの分野で広く応用されており、Union-Findの代表的な応用例として重要です。",
			importance: "medium",
			examples: [
				"辺ソート: 重みの昇順で全辺を整列",
				"閉路検出: Union-Find.connected(u, v)",
				"辺採用: 連結されていない場合にUnion実行",
				"計算量: O(E log E) + O(E α(V))",
			],
			formula:
				"クラスカル法アルゴリズム:<br>1. 全辺を重み順ソート<br>2. for each edge (u,v):<br>&nbsp;&nbsp;&nbsp;if not connected(u,v):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add edge to MST<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union(u,v)<br><br>時間計算量: O(E log E)",
		},

		{
			id: "image-processing",
			title: "🖼️ 画像処理での連結成分ラベリング",
			content:
				"画像処理において、Union-Findは連結成分ラベリング（Connected Component Labeling）に使用されます。二値画像やセグメント化された画像で、隣接する同色ピクセルを一つの連結成分として識別する処理です。画像を左上から右下にスキャンし、各ピクセルについて上や左の隣接ピクセルと同じ値の場合にUnion操作を実行します。最終的に、同じ代表元を持つピクセルが一つの連結成分を形成します。この手法は、物体認識、文字認識、医療画像解析などで重要な前処理として使用されます。特に大きな画像では、Union-Findの効率性が処理時間に大きな影響を与えます。また、リアルタイム画像処理や動画解析においても、フレーム間の連結成分の対応関係を効率的に管理できます。",
			importance: "low",
			examples: [
				"ピクセルスキャン: 左上から右下への順次処理",
				"隣接判定: 上・左ピクセルとの値比較",
				"ラベル統合: 同じ連結成分のピクセルを統合",
				"最終ラベリング: 各ピクセルに連結成分IDを割当",
			],
		},

		{
			id: "union-find-variations",
			title: "🔄 Union-Findの拡張と応用",
			content:
				"基本的なUnion-Findには、様々な拡張や改良版が開発されています。Weighted Union-Findでは、要素間に重みや距離の概念を導入し、相対的な関係を管理できます。Persistent Union-Findでは、過去の状態を保持することで、時間を遡った問い合わせに対応できます。Rollback Union-Findでは、操作の取り消しが可能で、バックトラッキングアルゴリズムで有用です。また、Union-Split Tree では、集合の分割操作もサポートします。Parallel Union-Findでは、並列処理環境での効率的な実装を提供します。これらの拡張は、特定の問題領域や制約に対してより適切な解決策を提供し、Union-Findの応用範囲を大幅に拡大しています。選択する拡張は、問題の要件と性能特性を慎重に考慮して決定する必要があります。",
			importance: "low",
			examples: [
				"Weighted UF: 要素間の距離・重み管理",
				"Persistent UF: 履歴保持と時間遡行",
				"Rollback UF: 操作の取り消し機能",
				"Parallel UF: 並列処理対応版",
			],
		},

		{
			id: "implementation-considerations",
			title: "💻 実装上の考慮事項と最適化",
			content:
				"Union-Findの効率的な実装には、いくつかの重要な考慮事項があります。メモリ管理では、配列のサイズと要素の範囲を適切に設定し、メモリ使用量を最小化します。要素が整数でない場合は、ハッシュテーブルによるマッピングが必要です。エラーハンドリングでは、無効な要素や範囲外アクセスを適切に検出し、安全性を確保します。性能最適化では、キャッシュ効率を考慮したメモリレイアウト、分岐予測に優しいコード構造が重要です。また、実際の使用パターンに応じて、パス圧縮の方法（再帰 vs 反復）やランク管理の詳細を調整できます。大規模データでは、初期化コストやガベージコレクションの影響も考慮が必要です。これらの実装上の配慮により、理論的性能を実際のシステムでも実現できます。",
			importance: "medium",
			examples: [
				"メモリ効率: 配列サイズの適切な設定",
				"要素マッピング: 非整数要素のハッシュ管理",
				"エラー処理: 範囲外アクセスの検出",
				"性能調整: キャッシュ効率と分岐最適化",
			],
		},

		{
			id: "competitive-programming",
			title: "🏆 競技プログラミングでの活用",
			content:
				"Union-Findは競技プログラミングにおいて頻出の重要なデータ構造です。グラフの連結性に関する問題、動的な集合管理、最小全域木構築などで必須の知識となっています。典型的な問題パターンとして、友達関係の管理、ネットワークの連結判定、島の形成過程、道路建設の最適化などがあります。実装時間の短縮のため、テンプレート化された効率的なコードを用意しておくことが重要です。また、問題の制約に応じて、basic版、path compression版、union by rank版、full optimized版を使い分ける必要があります。時間制限が厳しい問題では、定数倍の最適化やメモリアクセスパターンの改善が重要になります。Union-Findを使う問題は、多くの場合、他のアルゴリズムと組み合わせて出題されるため、総合的な理解が求められます。",
			importance: "low",
			examples: [
				"典型問題: 友達関係、連結判定、島形成",
				"実装戦略: テンプレート化と最適化レベル選択",
				"時間最適化: 定数倍削減とメモリ効率",
				"組み合わせ: 他アルゴリズムとの複合問題",
			],
		},

		{
			id: "theoretical-significance",
			title: "🎓 理論的意義と研究価値",
			content:
				"Union-Findは、データ構造とアルゴリズム理論において重要な理論的意義を持ちます。逆アッカーマン関数による計算量解析は、償却解析の代表例として教育的価値が高く、アルゴリズム解析技法の発展に貢献しました。また、最適性の証明により、この問題に対するオンラインアルゴリズムとして理論的に最良であることが示されています。パス圧縮とランク合併の組み合わせが最適性を達成するという結果は、アルゴリズム設計における最適化の重要性を示しています。さらに、並列アルゴリズム、近似アルゴリズム、オンラインアルゴリズムなど、様々な計算モデルでの研究対象となっています。Union-Findの研究は、効率的なデータ構造設計の原理を理解し、新しいアルゴリズムの開発に向けた重要な知見を提供しています。",
			importance: "low",
			examples: [
				"償却解析: 逆アッカーマン関数の理論的重要性",
				"最適性証明: オンラインアルゴリズムの下界",
				"研究発展: 並列・近似・オンラインアルゴリズム",
				"設計原理: 効率的データ構造の基本概念",
			],
			formula:
				"理論的結果:<br>• 下界: Ω(m α(n)) (Tarjan, 1975)<br>• 上界: O(m α(n)) (実装による達成)<br>• 最適性: 漸近的に最良のオンラインアルゴリズム<br>• 償却解析: potential method による証明",
		},
	],
};
