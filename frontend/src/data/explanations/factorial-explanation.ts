/**
 * src/data/explanations/factorial-explanation.ts
 *
 * 階乗の計算（再帰）の解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "../../components/calculator/CalculationExplanation";

/**
 * 階乗の計算（再帰）の解説データ
 * 再帰アルゴリズムの基本概念から実装まで段階的に説明
 */
export const factorialExplanation: ExplanationData = {
	calculationType: "factorial_recursive",
	title: "階乗の計算（再帰）アルゴリズムとは？",
	overview:
		"階乗（factorial）は、自然数nに対してn! = n × (n-1) × (n-2) × ... × 1で定義される数学的概念です。再帰アルゴリズムで実装すると、n! = n × (n-1)!という単純な定義をそのままコードで表現できます。フィボナッチ数列よりもシンプルな線形再帰構造で、再帰プログラミングの入門に最適なアルゴリズムです。",

	sections: [
		{
			id: "factorial-definition",
			title: "🔢 階乗の数学的定義",
			content:
				"階乗は数学において、自然数nに対してn以下の全ての正の整数の積として定義されます。0! = 1と定義され、n! = n × (n-1)!という再帰的な性質を持ちます。この定義は直接的にプログラムの再帰関数として実装でき、数学的定義とプログラム実装の美しい対応関係を学ぶことができます。",
			importance: "high",
			examples: [
				"0! = 1 （定義による）",
				"1! = 1",
				"2! = 2 × 1 = 2",
				"3! = 3 × 2 × 1 = 6",
				"4! = 4 × 3 × 2 × 1 = 24",
				"5! = 5 × 4 × 3 × 2 × 1 = 120",
			],
		},

		{
			id: "recursive-structure",
			title: "🔄 再帰構造の理解",
			content:
				"階乗の再帰的定義 n! = n × (n-1)! は、問題を同じ種類のより小さな問題に分解する典型的な例です。各ステップで問題のサイズが1ずつ減少し、最終的にベースケース（0! = 1または1! = 1）に到達します。この線形再帰構造は、フィボナッチ数列の指数的再帰よりもシンプルで理解しやすく、再帰プログラミングの基礎を学ぶのに適しています。",
			importance: "high",
			examples: [
				"5! を計算する場合:",
				"5! = 5 × 4!",
				"4! = 4 × 3!",
				"3! = 3 × 2!",
				"2! = 2 × 1!",
				"1! = 1 （ベースケース）",
			],
		},

		{
			id: "base-case-analysis",
			title: "🛑 ベースケースの設計",
			content:
				"階乗のベースケースは、通常0! = 1または1! = 1に設定されます。数学的には0! = 1が正しい定義ですが、プログラム実装では1! = 1をベースケースとすることも多いです。重要なのは、再帰が無限に続かないよう適切な停止条件を設定することです。負数に対する階乗は未定義なので、入力値の検証も重要な実装要素です。",
			importance: "high",
			examples: [
				"数学的定義: 0! = 1, n! = n × (n-1)! (n ≥ 1)",
				"プログラム実装A: if (n <= 1) return 1;",
				"プログラム実装B: if (n === 0) return 1; if (n === 1) return 1;",
				"エラーケース: n < 0 の場合は未定義",
			],
		},

		{
			id: "call-stack-mechanics",
			title: "📚 コールスタックの動作",
			content:
				"階乗の再帰実装では、各関数呼び出しがスタックに積まれ、ベースケースに到達すると逆順に計算が実行されます。5!の計算では、factorial(5) → factorial(4) → ... → factorial(1)の順でスタックに積まれ、1 → 2 → 6 → 24 → 120の順で結果が計算されます。この過程を理解することで、再帰の実行メカニズムとメモリ使用パターンを把握できます。",
			importance: "medium",
			examples: [
				"スタックに積まれる順序: f(5) → f(4) → f(3) → f(2) → f(1)",
				"計算される順序: 1 ← 2 ← 6 ← 24 ← 120",
				"各段階: f(1)=1, f(2)=2×1=2, f(3)=3×2=6, ...",
				"メモリ使用量: O(n) （スタックの深さ）",
			],
		},

		{
			id: "time-space-complexity",
			title: "⏱️ 計算量の分析",
			content:
				"階乗の再帰実装の時間計算量はO(n)です。n回の関数呼び出しが必要で、各呼び出しは定数時間で処理されます。空間計算量もO(n)で、これは再帰の深さがnであるためです。フィボナッチ数列のO(2^n)と比較すると格段に効率的で、実用的な計算時間で実行できます。ただし、大きなnに対しては結果が非常に大きくなるため、オーバーフローに注意が必要です。",
			formula:
				"時間計算量: O(n)<br>空間計算量: O(n) （再帰の深さ）<br><br>関数呼び出し回数: n回<br>スタック使用量: n個の関数フレーム<br>計算効率: 線形時間で実用的",
			importance: "medium",
			examples: [
				"10!の計算: 10回の関数呼び出し",
				"20!の計算: 20回の関数呼び出し",
				"線形時間: 入力サイズに比例した実行時間",
				"注意: 20!以上では数値オーバーフローの可能性",
			],
		},

		{
			id: "comparison-with-iterative",
			title: "🔄 反復実装との比較",
			content:
				"階乗は再帰実装と反復実装（ループ）の両方で簡単に記述できます。再帰実装は数学的定義に忠実で理解しやすい一方、反復実装はスタックを使用せずメモリ効率が良いです。教育目的では再帰実装が概念理解に適していますが、実用面では反復実装が推奨されることが多いです。両方の実装を比較することで、アルゴリズム設計の選択肢を理解できます。",
			importance: "medium",
			examples: [
				"再帰: factorial(n) = n * factorial(n-1)",
				"反復: result = 1; for(i=1; i<=n; i++) result *= i;",
				"再帰の利点: 直感的、数学的定義に忠実",
				"反復の利点: メモリ効率、スタックオーバーフロー回避",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実際の応用場面",
			content:
				"階乗は数学、統計学、コンピュータサイエンスの様々な分野で使用されます。組み合わせ論での順列・組み合わせ計算、確率論での確率計算、数値解析でのテイラー展開などで頻繁に現れます。プログラミングでは、再帰アルゴリズムの教育例として最初に学ぶことが多く、より複雑な再帰アルゴリズム（クイックソート、ハノイの塔など）の理解への足がかりとなります。",
			importance: "low",
			examples: [
				"組み合わせ論: C(n,k) = n! / (k!(n-k)!)",
				"確率計算: ポアソン分布、ガンマ関数",
				"数値計算: e^x のテイラー展開",
				"プログラミング教育: 再帰の入門例",
			],
		},

		{
			id: "overflow-considerations",
			title: "⚠️ オーバーフローの考慮",
			content:
				"階乗は非常に急速に増加する関数で、小さなnでも結果が巨大になります。JavaScriptの数値型（Number）では、20!（約2.4×10^18）付近で精度の問題が生じ、170!を超えるとInfinityになります。実用的な階乗計算では、BigInt型の使用や近似計算（スターリングの公式）、対数階乗の計算などの工夫が必要です。この問題を通して、数値計算の限界と対策を学ぶことができます。",
			importance: "medium",
			examples: [
				"13! = 6,227,020,800 （まだ安全）",
				"20! = 2,432,902,008,176,640,000 （精度の境界）",
				"25! = 1.5511210043330986e+25 （科学記法）",
				"対策: BigInt使用、対数計算、近似計算",
			],
		},
	],
};
