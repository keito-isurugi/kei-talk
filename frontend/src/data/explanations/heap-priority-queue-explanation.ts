/**
 * src/data/explanations/heap-priority-queue-explanation.ts
 *
 * ヒープ（優先度付きキュー）の解説データ
 * 完全二分木構造による効率的な優先度管理の理論と実装を包括的に説明
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * ヒープ（優先度付きキュー）の解説データ
 * 基本概念から実用的応用まで段階的に説明
 */
export const heapPriorityQueueExplanation: ExplanationData = {
	calculationType: "heap_priority_queue",
	title: "ヒープ（優先度付きキュー）とは？",
	overview:
		"ヒープ（Heap）は完全二分木の形をした特殊なデータ構造で、優先度付きキューの効率的な実装として広く使用されています。各ノードが特定の順序関係（ヒープ性質）を満たすことで、最大値や最小値への高速アクセスを実現し、O(log n)での挿入・削除、O(1)での最大/最小値取得を可能にします。配列による実装が可能で、親子関係の計算が簡単なため、実用性と理論の美しさを兼ね備えたデータ構造として、多くのアルゴリズムの基盤となっています。",

	sections: [
		{
			id: "basic-structure",
			title: "🌳 ヒープの基本構造",
			content:
				"ヒープは完全二分木の性質を持つ特殊なデータ構造です。完全二分木とは、最下段を除く全ての段が完全に埋まっており、最下段は左から順に埋まっている木構造を指します。この性質により、配列による効率的な実装が可能になり、親子関係を単純な計算で求めることができます。ヒープには最大ヒープと最小ヒープの2種類があり、最大ヒープでは親ノードが子ノードより大きく、最小ヒープでは親ノードが子ノードより小さくなります。配列実装では、インデックスiの要素に対して、左の子は2i+1、右の子は2i+2、親は⌊(i-1)/2⌋の位置にあります。",
			importance: "high",
			examples: [
				"完全二分木: [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]",
				"親子関係: 親i → 左子2i+1, 右子2i+2",
				"最大ヒープ性質: 16 ≥ 14, 16 ≥ 10, 14 ≥ 8, 14 ≥ 7",
				"配列表現: 木構造を一次元配列で効率的に表現",
			],
			formula:
				"完全二分木の性質:<br>• 左の子: 2i + 1<br>• 右の子: 2i + 2<br>• 親: ⌊(i-1)/2⌋<br><br>ヒープ性質:<br>• 最大ヒープ: parent ≥ children<br>• 最小ヒープ: parent ≤ children",
		},

		{
			id: "heap-operations",
			title: "⚡ 主要な操作と計算量",
			content:
				"ヒープの主要な操作は挿入（Insert）、削除（Extract）、最大/最小値取得（Peek）、ヒープ構築（Build）です。挿入操作では、新しい要素を配列の末尾に追加し、ヒープ性質を満たすまで親方向へ移動させる「bubble up」を実行します。削除操作では、根の要素を取り出し、最後の要素を根に移動してから「bubble down」でヒープ性質を修復します。最大/最小値取得は根の要素を参照するだけなのでO(1)です。ヒープ構築は配列からヒープを作る操作で、ボトムアップ方式により線形時間で実行できます。各操作の時間計算量は、挿入・削除がO(log n)、取得がO(1)、構築がO(n)となり、実用的な性能を提供します。",
			importance: "high",
			examples: [
				"挿入: 末尾追加 → bubble up → O(log n)",
				"削除: 根取得 → 末尾移動 → bubble down → O(log n)",
				"取得: 根参照 → O(1)",
				"構築: ボトムアップ → O(n)",
			],
			formula:
				"時間計算量:<br>• Insert: O(log n)<br>• Extract: O(log n)<br>• Peek: O(1)<br>• Build: O(n)<br><br>空間計算量: O(n)",
		},

		{
			id: "bubble-operations",
			title: "🔄 Bubble操作の仕組み",
			content:
				"ヒープでは、ヒープ性質を維持するために「bubble up」と「bubble down」という2つの重要な操作を使用します。Bubble upは、新しく挿入された要素や値が増加した要素を適切な位置まで上方向に移動させる操作です。子ノードが親ノードより大きい（最大ヒープの場合）間は、親子を交換し続けます。Bubble downは、根から削除された後や値が減少した要素を適切な位置まで下方向に移動させる操作です。親ノードが子ノードより小さい間は、より大きい子と交換し続けます。これらの操作により、ヒープ性質が局所的に破れても、効率的に全体の性質を修復できます。各操作は木の高さに比例するため、O(log n)の時間で完了します。",
			importance: "high",
			examples: [
				"Bubble up: 子→親への上昇移動",
				"Bubble down: 親→子への下降移動",
				"交換条件: ヒープ性質が破れている場合",
				"停止条件: 性質が満たされるか境界に到達",
			],
			formula:
				"Bubble up:<br>while (parent exists && compare(child, parent)):<br>&nbsp;&nbsp;swap(child, parent)<br>&nbsp;&nbsp;child = parent<br><br>Bubble down:<br>while (children exist && violation):<br>&nbsp;&nbsp;swap(parent, larger_child)<br>&nbsp;&nbsp;parent = larger_child",
		},

		{
			id: "array-implementation",
			title: "📊 配列による効率的実装",
			content:
				"ヒープの配列実装は、完全二分木の性質を活用した非常に効率的な方法です。配列のインデックス0から開始する場合、インデックスiの要素に対して、左の子は2i+1、右の子は2i+2、親は⌊(i-1)/2⌋で計算できます。この実装により、ポインタを使わずに木構造を表現でき、メモリ効率が向上します。また、キャッシュ効率も良く、実際の性能が理論値に近い値を示します。配列実装では、動的なメモリ確保が不要で、連続したメモリ領域を使用するため、メモリ断片化の心配もありません。さらに、親子関係の計算が単純な算術演算で済むため、実装が簡潔になり、バグの混入も少なくなります。",
			importance: "medium",
			examples: [
				"インデックス計算: 親⌊(i-1)/2⌋, 左子2i+1, 右子2i+2",
				"メモリ効率: ポインタ不要、連続領域使用",
				"キャッシュ効率: 局所性の良いアクセスパターン",
				"実装簡潔性: 単純な算術演算のみ",
			],
		},

		{
			id: "build-heap",
			title: "🏗️ ヒープ構築アルゴリズム",
			content:
				"配列からヒープを構築する際には、ボトムアップ方式を使用することで線形時間O(n)での構築が可能です。この方法では、最後の非葉ノード（インデックス⌊n/2⌋-1）から開始して、各ノードに対してbubble down操作を実行します。葉ノードは既にヒープ性質を満たしているため、内部ノードのみを処理すれば十分です。なぜO(n)で構築できるかというと、各レベルでの操作回数と移動距離を考慮すると、全体として線形時間に収束するためです。具体的には、最下位レベルの要素は移動しない、その上のレベルは最大1回移動、さらに上は最大2回移動となり、幾何級数的に減少します。この効率的な構築アルゴリズムにより、大量のデータからのヒープ生成が実用的な時間で完了します。",
			importance: "medium",
			examples: [
				"開始位置: 最後の非葉ノード⌊n/2⌋-1",
				"処理順序: 右から左、下から上",
				"各ノード: bubble down操作を実行",
				"計算量解析: Σ(h × 2^h) = O(n)",
			],
			formula:
				"構築アルゴリズム:<br>for i = ⌊n/2⌋-1 down to 0:<br>&nbsp;&nbsp;heapify(i)<br><br>時間計算量証明:<br>Σ(h=0 to log n) h × 2^h ≈ 2n = O(n)",
		},

		{
			id: "priority-queue-applications",
			title: "🎯 優先度付きキューとしての応用",
			content:
				"ヒープは優先度付きキューの最も効率的な実装として広く使用されています。優先度付きキューでは、要素に優先度が割り当てられ、常に最高（または最低）優先度の要素が最初に処理されます。オペレーティングシステムのタスクスケジューリングでは、プロセスの優先度に基づいてCPU時間を割り当てる際にヒープが使用されます。イベント駆動シミュレーションでは、次に処理すべきイベントの時刻順管理にヒープが活用されます。また、リアルタイムシステムでは、緊急度の高いタスクを優先的に処理するためのデータ構造として重要な役割を果たします。ヒープベースの優先度付きキューは、動的な優先度変更にも対応でき、システム設計において柔軟性を提供します。",
			importance: "medium",
			examples: [
				"タスクスケジューリング: プロセス優先度管理",
				"イベント処理: 時系列イベントの順序管理",
				"リアルタイムシステム: 緊急度ベース処理",
				"負荷分散: サーバーの処理能力考慮",
			],
		},

		{
			id: "graph-algorithms",
			title: "🗺️ グラフアルゴリズムでの活用",
			content:
				"ヒープは多くのグラフアルゴリズムで中核的な役割を果たします。ダイクストラ法では、各頂点への最短距離を管理する優先度付きキューとしてヒープを使用し、常に最小距離の頂点を効率的に取得します。プリム法による最小全域木構築では、各頂点から最小重みの辺を見つけるためにヒープが活用されます。A*アルゴリズムでは、推定コストと実際のコストの合計値でノードの優先度を決定し、最適な探索順序を実現します。これらのアルゴリズムでは、ヒープの効率的な挿入・削除性能が全体の計算量を大きく左右するため、ヒープの選択が重要な設計決定となります。特に大規模なグラフでは、ヒープの性能差が実行時間に顕著な影響を与えます。",
			importance: "medium",
			examples: [
				"ダイクストラ法: 最短距離の頂点を高速選択",
				"プリム法: 最小重み辺の効率的発見",
				"A*探索: 推定コストによる探索順序最適化",
				"ネットワークルーティング: 経路計算の高速化",
			],
		},

		{
			id: "heap-variations",
			title: "🔄 ヒープの種類と拡張",
			content:
				"基本的な二分ヒープ以外にも、用途に応じた様々なヒープの拡張が開発されています。d-ary heap（d分ヒープ）では、各ノードがd個の子を持つことで、木の高さを削減し、特定の操作を高速化できます。Fibonacci heapは、decreaseKey操作を償却O(1)で実行でき、一部のグラフアルゴリズムの理論的性能を向上させます。Binomial heapは、複数のヒープの効率的な合併（merge）操作をサポートします。Leftist heapやSkew heapは、主に理論研究で重要な性質を持ちます。また、Min-Max heapでは、同一の構造で最大値と最小値の両方を効率的に管理できます。これらの拡張は、特定の用途や制約に対してより適切な性能特性を提供し、アルゴリズム設計の選択肢を広げます。",
			importance: "low",
			examples: [
				"d-ary heap: 各ノードd個の子、高さ削減",
				"Fibonacci heap: decreaseKey O(1)償却",
				"Binomial heap: 効率的なmerge操作",
				"Min-Max heap: 最大・最小値同時管理",
			],
		},

		{
			id: "implementation-details",
			title: "💻 実装上の考慮事項",
			content:
				"ヒープの実装では、いくつかの重要な考慮事項があります。配列のサイズ管理では、動的な拡張・縮小を適切に行い、メモリ効率と性能のバランスを取る必要があります。比較関数の設計では、カスタムオブジェクトや複合的な優先度を適切に処理できる柔軟性が求められます。エラーハンドリングでは、空のヒープからの取得や無効なインデックスへのアクセスを適切に検出し、安全性を確保します。また、数値オーバーフローやアンダーフローへの対応、特に大きな数値を扱う場合の精度保持も重要です。パフォーマンス最適化では、キャッシュ効率を考慮した実装、分岐予測に優しいコード構造、コンパイラ最適化を活用した高速化が効果的です。これらの実装上の配慮により、理論的性能を実際のシステムでも実現できます。",
			importance: "medium",
			examples: [
				"動的配列管理: 拡張・縮小の効率的実装",
				"比較関数: カスタムオブジェクト対応",
				"エラー処理: 境界条件の適切な検出",
				"性能最適化: キャッシュ効率とコンパイラ最適化",
			],
		},

		{
			id: "real-world-applications",
			title: "🌍 実世界での応用例",
			content:
				"ヒープは現実世界の多くのシステムで重要な役割を果たしています。データベース管理システムでは、クエリの実行順序やインデックスの管理にヒープが使用されます。ネットワークルーティングでは、パケットの優先度や経路計算でヒープベースのアルゴリズムが活用されます。ゲーム開発では、AI の行動決定、物理シミュレーション、イベント管理などでヒープが使用されます。機械学習では、k最近傍探索やビームサーチでの候補管理にヒープが利用されます。リアルタイム画像・音声処理では、フレームやサンプルの優先度管理にヒープが不可欠です。また、株式取引システムでは、注文の価格優先・時間優先処理でヒープが使用され、高頻度取引の基盤技術となっています。これらの応用例は、ヒープの実用性と汎用性を示しています。",
			importance: "low",
			examples: [
				"データベース: クエリ実行計画とインデックス管理",
				"ネットワーク: パケット優先制御と経路最適化",
				"ゲーム開発: AI行動決定と物理シミュレーション",
				"金融システム: 取引注文の優先度処理",
			],
		},

		{
			id: "performance-analysis",
			title: "📈 性能分析と最適化",
			content:
				"ヒープの性能は、理論的計算量と実際の実行時間の両面から評価する必要があります。理論的には、主要操作がO(log n)で実行されますが、実際の性能は実装の詳細、データの特性、ハードウェアの特性に大きく依存します。キャッシュ効率では、配列実装により良好な局所性が得られ、メモリ階層を効果的に活用できます。分岐予測では、比較操作の結果が予測しやすい場合に性能が向上します。また、データの分布（ランダム、ソート済み、逆順など）によって実際の性能が変化することも重要な考慮点です。大規模データでは、メモリ使用量とガベージコレクションの影響も無視できません。性能測定では、単純な操作時間だけでなく、スループット、レイテンシ、メモリ使用効率を総合的に評価することが重要です。",
			importance: "medium",
			examples: [
				"理論計算量: O(log n)挿入・削除、O(1)取得",
				"キャッシュ効率: 配列実装による局所性向上",
				"実データ性能: 分布特性による性能変化",
				"スケーラビリティ: 大規模データでの動作特性",
			],
			formula:
				"性能評価指標:<br>• 時間計算量: 最悪・平均・最良ケース<br>• 空間計算量: メモリ使用効率<br>• キャッシュミス率: 実行時間への影響<br>• スループット: 単位時間あたりの処理量",
		},

		{
			id: "educational-value",
			title: "📚 教育的価値と学習意義",
			content:
				"ヒープは、データ構造とアルゴリズムの学習において極めて重要な教育的価値を持ちます。完全二分木の概念を具体的に学べ、木構造と配列実装の関係を理解できます。また、分割統治法の考え方、再帰的アルゴリズムの設計、計算量解析の実践などを通じて、アルゴリズム設計の基本原理を習得できます。さらに、抽象データ型（優先度付きキュー）と具体的実装（ヒープ）の関係を学ぶことで、ソフトウェア設計における抽象化の重要性を理解できます。ヒープソートを通じてソートアルゴリズムの多様性を学び、グラフアルゴリズムでの応用を通じて実用的なアルゴリズム設計を体験できます。これらの学習体験は、より高度なデータ構造やアルゴリズムの理解に向けた重要な基盤となります。",
			importance: "low",
			examples: [
				"木構造理解: 完全二分木と配列実装の関係",
				"アルゴリズム設計: 分割統治と再帰の実践",
				"抽象化概念: ADTと実装の分離",
				"応用展開: グラフアルゴリズムへの発展",
			],
		},
	],
};
