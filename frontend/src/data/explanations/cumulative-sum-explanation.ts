/**
 * src/data/explanations/cumulative-sum-explanation.ts
 *
 * 累積和・差分配列の解説データ
 * 効率的な区間操作の基本技法について学習者向けに詳解
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * 累積和・差分配列の解説データ
 * 前処理による区間操作の高速化から実用的応用まで段階的に説明
 */
export const cumulativeSumExplanation: ExplanationData = {
	calculationType: "cumulative_sum",
	title: "累積和・差分配列とは？",
	overview:
		"累積和（Cumulative Sum）と差分配列（Difference Array）は、配列の区間操作を劇的に高速化する前処理技法です。累積和により区間和クエリをO(1)で、差分配列により区間更新をO(1)で実行できます。これらの技法は競技プログラミングから実用アプリケーションまで幅広く使用され、多くの上位アルゴリズムの基盤となる重要な概念です。前処理O(n)により、その後の操作を大幅に効率化できる代表的な最適化手法です。",

	sections: [
		{
			id: "basic-concept",
			title: "🔢 累積和の基本概念",
			content:
				"累積和は配列の各位置までの要素の合計を事前に計算して格納する技法です。cumSum[i] = arr[0] + arr[1] + ... + arr[i-1] として定義され、区間[l, r]の合計をcumSum[r+1] - cumSum[l]で瞬時に計算できます。この単純な前処理により、O(n)時間を要していた区間和計算がO(1)時間で実行可能になります。",
			importance: "high",
			examples: [
				"配列[3,1,4,1,5] → 累積和[0,3,4,8,9,14]",
				"区間[1,3]の和: cumSum[4] - cumSum[1] = 9 - 3 = 6",
				"前処理O(n)で無限のO(1)クエリが可能",
				"メモリ使用量は元配列+累積和配列のO(n)",
			],
		},

		{
			id: "difference-array",
			title: "📊 差分配列の原理",
			content:
				"差分配列は隣接要素の差を格納する配列で、区間更新を効率化します。diff[i] = arr[i] - arr[i-1]として定義し、区間[l,r]に値vを加算するときはdiff[l] += v, diff[r+1] -= vの2回の操作で完了します。最終的に差分配列の累積和を計算することで、全ての区間更新が反映された元配列を復元できます。",
			importance: "high",
			examples: [
				"配列[3,1,4,1,5] → 差分[3,-2,3,-3,4]",
				"区間[1,3]に2を加算: diff[1]+=2, diff[4]-=2",
				"復元: 差分配列の累積和で元配列を求める",
				"複数の区間更新をO(1)ずつで処理",
			],
		},

		{
			id: "implementation-patterns",
			title: "💻 実装パターンと技法",
			content:
				"累積和実装では1-indexedの配列を使用することで境界処理が簡潔になります。cumSum[0] = 0として初期化し、区間[l,r]の和をcumSum[r+1] - cumSum[l]で計算します。差分配列では配列の範囲外アクセスに注意し、最終的な復元処理で全ての更新を一括適用します。これらの実装パターンを習得することで、効率的で読みやすいコードが書けます。",
			importance: "medium",
			examples: [
				"1-indexed累積和で境界条件を簡潔化",
				"差分配列の範囲外チェック: if (r+1 < n)",
				"遅延評価による効率的な区間更新",
				"オーバーフロー対策とlong型の使用",
			],
		},

		{
			id: "time-complexity",
			title: "⚡ 計算量の分析と改善効果",
			content:
				"ナイーブな区間和計算はO(n)時間ですが、累積和により O(1)に改善されます。q個のクエリがある場合、O(nq) → O(n+q)という劇的な改善です。差分配列による区間更新も同様で、ナイーブなO(n)更新がO(1)になります。前処理のコストO(n)は、複数のクエリを処理することで容易に回収できる投資です。",
			formula:
				"累積和の計算量:<br>前処理: O(n)<br>区間和クエリ: O(1)<br>q個クエリ: O(n + q)<br><br>差分配列の計算量:<br>区間更新: O(1)<br>最終復元: O(n)<br>q個更新: O(q + n)",
			importance: "high",
			examples: [
				"1000万要素×1000クエリ: 100億→1001万演算",
				"リアルタイム処理での応答性向上",
				"メモリ効率: 追加O(n)で大幅な時間短縮",
				"バッチ処理との相性が抜群",
			],
		},

		{
			id: "advanced-applications",
			title: "🌟 応用技法と拡張",
			content:
				"基本の累積和は2次元累積和（矩形領域の和）、累積XOR（ビット演算の区間処理）、累積最大値・最小値などに拡張できます。差分配列は座標圧縮と組み合わせて大きな座標空間での効率的処理、イベント処理での開始・終了の管理、スケジューリング問題での区間管理などに活用されます。これらの応用を理解することで、様々な問題への適用力が向上します。",
			importance: "medium",
			examples: [
				"2次元累積和: 矩形領域をO(1)で計算",
				"累積XOR: ビット演算の区間クエリ",
				"imos法: イベント処理の効率化",
				"座標圧縮との組み合わせ",
			],
		},

		{
			id: "real-world-examples",
			title: "🌍 実世界での活用例",
			content:
				"累積和・差分配列は様々な実用システムで活用されています。データベースでは集計クエリの高速化、画像処理では積分画像による高速フィルタリング、財務システムでは期間損益の高速計算、ゲーム開発では範囲攻撃の効率的な実装などに使用されます。これらの技法は理論だけでなく、実際のシステム開発でも重要な役割を果たしています。",
			importance: "medium",
			examples: [
				"データベース: OLAP処理での集計高速化",
				"画像処理: 積分画像による矩形フィルタ",
				"ゲーム: 範囲攻撃とエリア効果の計算",
				"IoTシステム: センサーデータの時系列集計",
			],
		},

		{
			id: "comparison-with-alternatives",
			title: "🔍 他の手法との比較",
			content:
				"累積和・差分配列は、セグメント木やFenwick Treeと比較して実装が簡潔で理解しやすいという利点があります。メモリ効率も良く、キャッシュ効率も優秀です。ただし、動的な更新と区間クエリを同時に扱う場合は、セグメント木の方が適している場合があります。問題の性質を理解して最適な手法を選択することが重要です。",
			importance: "low",
			examples: [
				"vs セグメント木: 実装簡潔、メモリ効率良",
				"vs Fenwick Tree: より直感的、範囲クエリ特化",
				"vs ナイーブ法: 劇的な性能向上",
				"vs 動的データ構造: 静的データに最適",
			],
		},

		{
			id: "common-pitfalls",
			title: "⚠️ よくある間違いと対策",
			content:
				"累積和実装でよくある間違いは、インデックスの境界エラーと0-indexed/1-indexedの混同です。差分配列では範囲外アクセスの見落としと、最終的な復元処理の忘れがあります。また、オーバーフローの可能性を考慮せずにint型で実装して桁あふれを起こすケースも多く見られます。これらの落とし穴を理解し、適切に対処することが重要です。",
			importance: "medium",
			examples: [
				"インデックス境界: 0 ≤ l ≤ r < n の確認",
				"型の選択: long long型でオーバーフロー対策",
				"範囲外アクセス: if (r+1 < n) のチェック",
				"復元忘れ: 差分配列から元配列への変換",
			],
		},

		{
			id: "learning-progression",
			title: "📚 効果的な学習方法",
			content:
				"累積和・差分配列の学習は、まず1次元の基本操作から始めて、徐々に2次元や応用パターンに進むのが効果的です。理論の理解と並行して、実際の問題を解くことで定着を図ります。特に競技プログラミングの典型問題を通じて、様々な応用パターンを身に付けることが重要です。最終的には、問題を見てすぐに累積和・差分配列の適用可能性を判断できるレベルを目指します。",
			importance: "low",
			examples: [
				"基礎: 1次元累積和の完全理解",
				"応用: 2次元・ビット演算への拡張",
				"実践: 競技プログラミング問題での演習",
				"習熟: 問題パターンの瞬時判断",
			],
		},
	],
};
