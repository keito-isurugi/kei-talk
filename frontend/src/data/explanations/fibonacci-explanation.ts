/**
 * src/data/explanations/fibonacci-explanation.ts
 *
 * フィボナッチ数列（再帰）の解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "../../components/calculator/CalculationExplanation";

/**
 * フィボナッチ数列（再帰）の解説データ
 * 再帰アルゴリズムの基本概念から実装まで段階的に説明
 */
export const fibonacciExplanation: ExplanationData = {
	calculationType: "fibonacci_recursive",
	title: "フィボナッチ数列（再帰）アルゴリズムとは？",
	overview:
		"フィボナッチ数列は、前の2つの数を足して次の数を作る数列です（0, 1, 1, 2, 3, 5, 8, 13, ...）。再帰アルゴリズムの教材として非常に人気が高く、関数が自分自身を呼び出すプログラミングの基本概念を学ぶのに最適です。ただし、純粋な再帰実装は指数的な計算量となり、大きな数値では非実用的であることも重要な学習ポイントです。",

	sections: [
		{
			id: "fibonacci-sequence-basics",
			title: "🔢 フィボナッチ数列の基本",
			content:
				"フィボナッチ数列は、最初の2つの数（通常0と1）を除いて、各数が前の2つの数の和となる数列です。この数列は13世紀のイタリアの数学者レオナルド・フィボナッチにちなんで名付けられました。自然界の多くの現象（花びらの数、貝殻の螺旋、植物の葉の配置など）でこのパターンが観察され、数学的美しさと実用性を兼ね備えています。",
			importance: "high",
			examples: [
				"F(0) = 0, F(1) = 1",
				"F(2) = F(1) + F(0) = 1 + 0 = 1",
				"F(3) = F(2) + F(1) = 1 + 1 = 2",
				"F(4) = F(3) + F(2) = 2 + 1 = 3",
				"数列: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...",
			],
		},

		{
			id: "recursive-thinking",
			title: "🔄 再帰的思考法の理解",
			content:
				"再帰とは、問題を同じ種類のより小さな問題に分解して解決する手法です。フィボナッチ数列では「F(n) = F(n-1) + F(n-2)」という定義そのものが再帰的です。この考え方により、複雑な問題を単純な基本ケース（ベースケース）まで分解できます。プログラミングでは、関数が自分自身を呼び出すことでこの概念を実現します。",
			importance: "high",
			examples: [
				"大きな問題: F(5)を求める",
				"小さな問題: F(4) + F(3)を求める",
				"さらに小さく: F(3)+F(2) + F(2)+F(1)",
				"基本ケース: F(0)=0, F(1)=1まで分解",
			],
		},

		{
			id: "base-case-importance",
			title: "🛑 ベースケースの重要性",
			content:
				"再帰アルゴリズムでは、再帰呼び出しを停止する条件（ベースケース）が必須です。フィボナッチ数列では、F(0)=0、F(1)=1がベースケースとなります。これらがないと無限再帰に陥り、プログラムがクラッシュします。ベースケースは再帰の「出口」であり、問題を解決可能な最小単位まで分解した状態を表します。",
			importance: "high",
			examples: [
				"F(0) = 0 （計算不要、直接値を返す）",
				"F(1) = 1 （計算不要、直接値を返す）",
				"F(n) = F(n-1) + F(n-2) （n ≥ 2の場合のみ再帰）",
				"ベースケースなし → 無限再帰 → スタックオーバーフロー",
			],
		},

		{
			id: "call-stack-visualization",
			title: "📚 コールスタックの動作",
			content:
				"再帰呼び出しは、メモリのスタック領域に関数呼び出しの情報を積み重ねていきます。フィボナッチ数列の計算では、各再帰呼び出しがスタックに追加され、ベースケースに到達すると逆順に結果が計算されて戻されます。この過程を理解することで、再帰アルゴリズムの実行メカニズムとメモリ使用量を把握できます。",
			importance: "medium",
			examples: [
				"F(3)呼び出し → スタックに追加",
				"F(2)呼び出し → スタックに追加",
				"F(1)呼び出し → ベースケース、1を返す",
				"F(0)呼び出し → ベースケース、0を返す",
				"スタックから逆順に計算して最終結果を取得",
			],
		},

		{
			id: "exponential-time-complexity",
			title: "⚠️ 指数的計算量の問題",
			content:
				"純粋な再帰実装のフィボナッチ数列は、同じ計算を何度も繰り返すため、時間計算量がO(2^n)となります。これは非常に非効率で、n=40程度でも数秒から数十秒かかります。この問題を通して、アルゴリズムの効率性の重要性と、最適化手法（メモ化、動的プログラミング）の必要性を学ぶことができます。",
			formula:
				"時間計算量: O(2^n)<br>空間計算量: O(n) （再帰の深さ）<br><br>計算回数の例:<br>F(5): 15回の関数呼び出し<br>F(10): 177回の関数呼び出し<br>F(20): 21,891回の関数呼び出し",
			importance: "high",
			examples: [
				"F(5)計算時にF(3)が2回、F(2)が3回計算される",
				"重複計算により指数的に実行時間が増加",
				"実用的な解決策：メモ化（結果をキャッシュ）",
				"代替手法：反復的実装（ループ使用）",
			],
		},

		{
			id: "recursive-tree-structure",
			title: "🌳 再帰ツリー構造",
			content:
				"フィボナッチ数列の再帰呼び出しは、二分木のような構造を形成します。各ノードが関数呼び出しを表し、子ノードがその関数内での再帰呼び出しを表します。この視覚化により、なぜ計算量が指数的になるのか、どの計算が重複しているのかを直感的に理解できます。プログラムの実行過程を木構造で表現する重要な概念です。",
			importance: "medium",
			examples: [
				"F(4)がルートノード",
				"F(3)とF(2)が子ノード",
				"F(2)とF(1)、F(1)とF(0)がさらに子ノード",
				"葉ノードがベースケース（F(0), F(1)）",
			],
		},

		{
			id: "learning-objectives",
			title: "🎯 学習目標と教育的価値",
			content:
				"フィボナッチ数列の再帰実装は、コンピュータサイエンスの基礎概念を学ぶのに最適な教材です。再帰的思考、関数呼び出しの仕組み、スタックの動作、計算量の概念、アルゴリズムの最適化の必要性など、多くの重要な概念を一度に学習できます。また、理論と実践のギャップを体験し、効率的なアルゴリズム設計の重要性を実感できます。",
			importance: "low",
			examples: [
				"再帰的思考法の習得",
				"ベースケースと再帰ケースの理解",
				"スタックとメモリ管理の概念",
				"計算量分析の基礎",
				"アルゴリズム最適化の動機付け",
			],
		},

		{
			id: "optimization-approaches",
			title: "🚀 最適化手法の紹介",
			content:
				"純粋な再帰実装の問題を解決するため、様々な最適化手法が存在します。メモ化（計算結果をキャッシュ）により時間計算量をO(n)に改善できます。動的プログラミングによるボトムアップ手法や、反復的な実装も効果的です。さらに高度な手法として、行列の累乗を使った O(log n) 解法も存在します。",
			importance: "low",
			examples: [
				"メモ化: 計算済み結果をハッシュテーブルに保存",
				"動的プログラミング: 小さい値から順番に計算",
				"反復的実装: ループを使用した線形計算",
				"行列累乗: 数学的手法による対数時間解法",
			],
		},
	],
};
