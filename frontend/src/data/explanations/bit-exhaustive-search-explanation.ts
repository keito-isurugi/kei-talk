/**
 * src/data/explanations/bit-exhaustive-search-explanation.ts
 *
 * ビット全探索の解説データ
 * 組み合わせ問題を効率的に解く技法について詳解
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * ビット全探索の解説データ
 * ビット演算による組み合わせ最適化から実用応用まで段階的に説明
 */
export const bitExhaustiveSearchExplanation: ExplanationData = {
	calculationType: "bit_exhaustive_search",
	title: "ビット全探索とは？",
	overview:
		"ビット全探索（Bit Exhaustive Search）は、ビット演算を使用して全ての組み合わせを系統的に探索するアルゴリズム技法です。n個の要素から2^n通りの部分集合を効率的に生成・評価し、組み合わせ最適化問題を解決できます。実装がシンプルで理解しやすく、小〜中規模の問題で確実な最適解を発見できるため、競技プログラミングや実用システムで重要な役割を果たします。",

	sections: [
		{
			id: "bit-representation",
			title: "🔢 ビット表現による組み合わせ",
			content:
				"ビット全探索の核心は、整数のビット表現を使って部分集合を表現することです。n個の要素に対して、0から2^n-1までの整数を使い、各ビットが対応する要素の選択/非選択を表します。例えば、4個の要素では0101₂（=5）は1番目と3番目の要素を選択することを意味します。この表現により、全ての組み合わせを漏れなく系統的に列挙できます。",
			importance: "high",
			examples: [
				"要素[A,B,C,D]で1011₂ → A,C,Dを選択",
				"0000₂ → 空集合（何も選択しない）",
				"1111₂ → 全集合（全て選択）",
				"2^n通りの組み合わせを完全網羅",
			],
		},

		{
			id: "bit-operations",
			title: "⚙️ ビット演算の基本操作",
			content:
				"ビット全探索では、右シフト（>>）とAND演算（&）を組み合わせてビット判定を行います。(mask >> i) & 1により、i番目のビットが1かどうかを判定できます。この操作により、各マスク値に対して対応する部分集合を効率的に構築できます。ビット演算の理解は、効率的で読みやすいコードを書くための基盤となります。",
			importance: "high",
			examples: [
				"(5 >> 0) & 1 = 1 → 0番目要素を選択",
				"(5 >> 1) & 1 = 0 → 1番目要素を非選択",
				"(5 >> 2) & 1 = 1 → 2番目要素を選択",
				"for文とビット演算の組み合わせで自動化",
			],
		},

		{
			id: "complexity-analysis",
			title: "📊 計算量の分析",
			content:
				"ビット全探索の時間計算量はO(2^n × 処理時間)です。2^n個の組み合わせそれぞれに対して部分集合の構築と評価を行うため、指数的な時間がかかります。実用的には n ≤ 20程度が限界ですが、この範囲では確実な最適解を発見できます。空間計算量は通常O(1)で、メモリ効率に優れています。小規模問題での完全解法として重要な位置を占めます。",
			formula:
				"ビット全探索の計算量:<br>時間計算量: O(2^n × m) (m: 各組み合わせの処理時間)<br>空間計算量: O(1) (結果保存を除く)<br><br>実用範囲:<br>n ≤ 20: 約100万組み合わせ（実用的）<br>n ≤ 25: 約3300万組み合わせ（限界）",
			importance: "high",
			examples: [
				"n=10: 1024組み合わせ（瞬時）",
				"n=15: 32768組み合わせ（高速）",
				"n=20: 1048576組み合わせ（実用）",
				"n=25: 33554432組み合わせ（限界）",
			],
		},

		{
			id: "subset-problems",
			title: "🎯 部分集合問題への応用",
			content:
				"ビット全探索は部分集合に関する様々な問題で威力を発揮します。部分集合和問題、最大部分集合和、制約付き選択問題などで確実な解を発見できます。各組み合わせを系統的に評価することで、動的計画法では複雑になる問題も直感的に解けます。特に制約が複雑で状態遷移が困難な場合に、シンプルで確実な解法を提供します。",
			importance: "high",
			examples: [
				"部分集合和: 指定された和になる組み合わせ",
				"ナップサック: 容量制約下での価値最大化",
				"制約充足: 複数条件を満たす組み合わせ",
				"最適化: 目的関数の最大/最小値探索",
			],
		},

		{
			id: "optimization-strategies",
			title: "🚀 最適化戦略",
			content:
				"基本のビット全探索にはいくつかの最適化戦略があります。早期終了による不要な探索の回避、制約による枝刈り、ビット演算の高速化などが効果的です。また、問題の性質を利用した順序付けや、対称性を利用した探索空間の削減も有効です。これらの最適化により、より大きな問題にも対応できる場合があります。",
			importance: "medium",
			examples: [
				"早期終了: 最適解発見時の即座停止",
				"制約枝刈り: 条件違反時のスキップ",
				"対称性利用: 重複パターンの除外",
				"順序最適化: 有望解優先の探索",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実用的な応用例",
			content:
				"ビット全探索は様々な実用システムで活用されています。リソース配分問題、スケジューリング最適化、特徴選択、組み合わせ設計などで重要な役割を果たします。特に、制約が複雑で他の手法では扱いが困難な小規模最適化問題において、確実で実装しやすい解法として価値があります。",
			importance: "medium",
			examples: [
				"リソース配分: 限られた資源の最適割り当て",
				"タスクスケジューリング: 作業の組み合わせ最適化",
				"機械学習: 特徴選択とモデル最適化",
				"回路設計: 論理回路の最適化",
			],
		},

		{
			id: "comparison-with-alternatives",
			title: "🔍 他手法との比較",
			content:
				"ビット全探索は他の探索手法と比較して、実装の簡潔性と確実性で優れています。動的計画法と比べて状態設計が不要で、再帰的探索と比べてスタックオーバーフローの心配がありません。ただし、指数的時間のため大規模問題には不適です。問題のサイズと制約を考慮して、適切な手法を選択することが重要です。",
			importance: "low",
			examples: [
				"vs 動的計画法: 実装簡潔、状態設計不要",
				"vs 再帰探索: スタックオーバーフローなし",
				"vs 貪欲法: 最適解を確実に発見",
				"vs 近似解法: 小規模なら厳密解が得られる",
			],
		},

		{
			id: "implementation-patterns",
			title: "💻 実装パターンと技法",
			content:
				"ビット全探索の実装には基本的なパターンがあります。外側のループで全マスクを走査し、内側のループで各ビットを判定して部分集合を構築、評価関数で条件をチェックするという流れです。エラーハンドリング、オーバーフロー対策、効率的なビット操作の実装が、品質の高いコードを作成するポイントとなります。",
			importance: "medium",
			examples: [
				"基本構造: for(mask=0; mask<(1<<n); mask++)",
				"ビット判定: if((mask>>i)&1) subset.push(arr[i])",
				"条件評価: 構築した部分集合の評価",
				"結果管理: 最適解の保存と更新",
			],
		},

		{
			id: "advanced-techniques",
			title: "🎓 発展的な技法",
			content:
				"基本のビット全探索を発展させた高度な技法には、部分集合の部分集合を扱うSoS（Sum over Subsets）DP、ビットマスクDP、並列処理による高速化などがあります。これらの技法により、より複雑な問題や大規模な問題にも対応できる場合があります。競技プログラミングの上級問題や研究レベルの問題で活用される重要な発展形です。",
			importance: "low",
			examples: [
				"SoS DP: 部分集合の部分集合を効率処理",
				"ビットマスクDP: 状態圧縮による高速化",
				"並列処理: マルチコアでの分散計算",
				"メモ化: 重複計算の排除",
			],
		},

		{
			id: "learning-approach",
			title: "📚 効果的な学習アプローチ",
			content:
				"ビット全探索の習得は、まずビット演算の基本から始めて、簡単な部分集合列挙、部分集合和問題、最適化問題の順に進むのが効果的です。各段階でビット表現と実際の組み合わせの対応を意識し、手計算での確認も行うことで理解が深まります。最終的には、問題を見てビット全探索の適用可能性を瞬時に判断できるレベルを目指します。",
			importance: "low",
			examples: [
				"基礎: ビット演算とマスク表現",
				"応用: 部分集合和と最適化問題",
				"発展: 制約付き問題と高速化",
				"習熟: 適用判断とパターン認識",
			],
		},
	],
};
