/**
 * src/data/explanations/lcs-dp-explanation.ts
 *
 * 最長共通部分列（LCS）動的計画法の解説データ
 * 文字列アルゴリズムとDPの学習向け
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * 最長共通部分列（LCS）動的計画法の解説データ
 * 基本概念から効率的な実装、応用まで段階的に説明
 */
export const lcsDpExplanation: ExplanationData = {
	calculationType: "lcs_dp",
	title: "最長共通部分列（LCS）動的計画法とは？",
	overview:
		"最長共通部分列（Longest Common Subsequence, LCS）は、2つの文字列に共通する最長の部分列を求める問題です。動的計画法を使用することで、全探索のO(2^n)からO(m×n)に大幅に改善できます。文字列の類似性測定、DNA配列解析、版数管理システムのdiff機能、文書校正など、様々な分野で重要な役割を果たします。二次元DPテーブルとバックトラッキングにより、効率的な解法と実際の部分列の復元の両方を実現します。",

	sections: [
		{
			id: "problem-definition",
			title: "🎯 LCS問題の定義",
			content:
				"最長共通部分列問題は、2つの文字列が与えられたとき、両方に共通して現れる最長の部分列を見つける問題です。部分列とは、元の文字列から文字を削除して得られる文字列で、残った文字の順序は保持されます。例えば、'ABCDGH'と'AEDFHR'のLCSは'ADH'（長さ3）です。部分文字列とは異なり、文字が連続している必要はありません。この問題は計算機科学の様々な分野で基本的な構成要素として使用されます。",
			importance: "high",
			examples: [
				"'ABCDGH' と 'AEDFHR' → LCS: 'ADH' (長さ3)",
				"'AGGTAB' と 'GXTXAYB' → LCS: 'GTAB' (長さ4)",
				"'ABC' と 'DEF' → LCS: '' (長さ0、共通部分なし)",
				"'HELLO' と 'HELLO' → LCS: 'HELLO' (長さ5、同一文字列)",
			],
		},

		{
			id: "naive-approach-problems",
			title: "🔍 全探索アプローチの問題点",
			content:
				"LCS問題を全探索で解く場合、各文字列のすべての部分列を生成し、共通する最長のものを探す必要があります。長さnの文字列には2^n個の部分列があるため、時間計算量は O(2^(m+n)) となり、文字列が長くなると実用的でなくなります。例えば、長さ20の文字列では約100万個、長さ30では約10億個の部分列があります。この指数的な増加により、動的計画法による効率的な解法が必要になります。",
			importance: "high",
			examples: [
				"長さ10の文字列: 2^10 = 1,024個の部分列",
				"長さ20の文字列: 2^20 = 1,048,576個の部分列",
				"長さ30の文字列: 2^30 = 1,073,741,824個の部分列",
				"DNA配列（数千文字）: 全探索は事実上不可能",
			],
		},

		{
			id: "dp-state-design",
			title: "📊 動的計画法の状態設計",
			content:
				"LCSの動的計画法では、dp[i][j]を「文字列1の最初のi文字と文字列2の最初のj文字のLCSの長さ」として定義します。この状態設計により、部分問題の最適解を組み合わせて全体の最適解を構築できます。各セルの値は、文字が一致する場合と一致しない場合で異なる計算を行います。最終的な答えはdp[m][n]（mとnは各文字列の長さ）に格納されます。",
			importance: "high",
			examples: [
				"dp[0][j] = 0 （空文字列との LCS は長さ 0）",
				"dp[i][0] = 0 （空文字列との LCS は長さ 0）",
				"dp[i][j] = 文字列1のi文字と文字列2のj文字のLCS長",
				"dp[m][n] = 最終的なLCSの長さ",
			],
		},

		{
			id: "state-transition",
			title: "🔄 状態遷移の仕組み",
			content:
				"各セル dp[i][j] の値は、現在比較している文字が一致するかどうかで決まります。文字が一致する場合（str1[i-1] == str2[j-1]）、dp[i][j] = dp[i-1][j-1] + 1 となります。文字が一致しない場合、dp[i][j] = max(dp[i-1][j], dp[i][j-1]) となります。この遷移により、各文字の包含・除外の選択を最適化し、重複する部分問題を効率的に解決します。",
			importance: "high",
			formula:
				"状態遷移式:<br><br>if str1[i-1] == str2[j-1]:<br>&nbsp;&nbsp;dp[i][j] = dp[i-1][j-1] + 1<br>else:<br>&nbsp;&nbsp;dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
			examples: [
				"文字一致: 対角線上の値+1を採用",
				"文字不一致: 上または左の最大値を採用",
				"選択の意味: 各文字を含める/含めないの最適判断",
				"累積効果: 局所最適が全体最適を構築",
			],
		},

		{
			id: "table-construction",
			title: "🏗️ DPテーブルの構築",
			content:
				"DPテーブルは行ごと（各文字ごと）に構築していきます。まず0行目と0列目をベースケース（0）で初期化し、その後1行目から順番に各セルを計算します。各セルの計算では、現在の文字ペアが一致するかを確認し、適切な遷移式を適用します。この過程により、最適部分構造の性質を活用して、全体の最適解が効率的に求められます。",
			importance: "medium",
			examples: [
				"初期化: 0行目と0列目をすべて0に設定",
				"行ごと処理: 文字列1の各文字について順次計算",
				"セル計算: 文字一致・不一致に応じた値決定",
				"最終値: 右下のセルに LCS の長さが格納",
			],
		},

		{
			id: "backtracking-reconstruction",
			title: "🔍 バックトラッキングによる解の復元",
			content:
				"DPテーブルからは LCS の長さだけでなく、実際の LCS 文字列も復元できます。右下から左上に向かってバックトラッキングを行い、各段階で値の変化を調べます。dp[i][j] が dp[i-1][j-1] + 1 の場合、対応する文字が LCS に含まれます。文字が一致しないセルでは、値が大きい方向（上または左）に向かって進みます。この過程により、実際の LCS 文字列を構築できます。",
			importance: "medium",
			examples: [
				"開始: 右下のセル dp[m][n] から開始",
				"文字採用: 対角線移動時に文字を LCS に追加",
				"方向選択: 値の大きい方向（上/左）を選択",
				"終了: 左上端に到達で復元完了",
			],
		},

		{
			id: "complexity-analysis",
			title: "⚡ 計算量の分析",
			content:
				"LCS の動的計画法による解法の時間計算量は O(m×n)、空間計算量は O(m×n) です（mとnは各文字列の長さ）。これは全探索の O(2^(m+n)) と比べて大幅な改善です。実際の例では、長さ1000の文字列でも100万回の計算で完了し、現実的な時間で処理できます。空間計算量の最適化により O(min(m,n)) に削減することも可能ですが、LCS文字列の復元には完全なテーブルが必要です。",
			formula:
				"LCS動的計画法の計算量:<br>時間計算量: O(m×n)<br>空間計算量: O(m×n)<br><br>比較例（m=n=20）:<br>全探索: 2^40 ≈ 1兆回<br>DP: 20×20 = 400回<br><br>改善率: 約25億倍の高速化",
			importance: "high",
			examples: [
				"小規模: 数十文字の文字列で瞬時に計算",
				"中規模: 数百文字でも実用的な速度",
				"大規模: DNA配列（数千文字）でも処理可能",
				"最適化: 空間効率の改善版も存在",
			],
		},

		{
			id: "real-world-applications",
			title: "🌍 実世界での応用",
			content:
				"LCS は様々な実世界の問題で重要な役割を果たします。バージョン管理システム（Git など）では、ファイルの差分検出に使用されます。DNA配列解析では、遺伝子の類似性や進化的関係の研究に活用されます。文書校正システムでは、原稿と校正版の比較に使用され、テキストエディタでは変更履歴の管理に応用されます。また、機械翻訳や自然言語処理でも文の類似性測定に使用されています。",
			importance: "low",
			examples: [
				"Git: ファイルの差分検出と merge 処理",
				"生物情報学: DNA/タンパク質配列の類似性解析",
				"文書処理: 校正支援と変更履歴管理",
				"自然言語処理: 文の類似性測定と翻訳支援",
			],
		},

		{
			id: "variants-and-extensions",
			title: "🔄 LCS の変形と拡張",
			content:
				"基本的な LCS から派生した様々な変形問題があります。重み付き LCS では、文字マッチに重みを付けて最適化します。Edit Distance（編集距離）は LCS と密接に関連し、文字列の変換コストを計算します。複数文字列の LCS では、3つ以上の文字列の共通部分列を求めます。また、制約付き LCS では、特定のパターンを含む/除外する条件下で LCS を求めます。これらの拡張により、より複雑な実用問題に対応できます。",
			importance: "medium",
			examples: [
				"重み付きLCS: 文字マッチに異なる重みを設定",
				"編集距離: 挿入・削除・置換の最小コスト",
				"複数文字列LCS: 3つ以上の文字列での共通部分",
				"制約付きLCS: 特定パターンの包含/除外条件",
			],
		},

		{
			id: "optimization-techniques",
			title: "🚀 最適化技法",
			content:
				"LCS の基本実装にはいくつかの最適化技法があります。空間効率の改善では、前の行の情報のみを保持することで O(min(m,n)) の空間計算量を実現できます。Hirschberg のアルゴリズムでは、分割統治法により O(min(m,n)) 空間で LCS 文字列も復元できます。また、文字の種類が少ない場合の特殊化や、前処理による高速化、並列化による性能向上なども重要な最適化手法です。",
			importance: "low",
			examples: [
				"空間最適化: O(min(m,n))空間での実装",
				"Hirschbergアルゴリズム: 最小空間での復元",
				"前処理最適化: 共通文字の事前検出",
				"並列化: マルチコアでの計算高速化",
			],
		},

		{
			id: "learning-progression",
			title: "📚 学習の進め方",
			content:
				"LCS の学習は、まず部分列の概念と問題定義の理解から始めます。次に小さな例で手動計算を行い、DP テーブルの構築過程を理解します。その後、基本的な実装を行い、バックトラッキングによる解の復元を学習します。応用として、編集距離やファイル差分などの関連問題に取り組み、最終的には実際のシステムでの使用例を学習します。理論と実装の両面から段階的に理解を深めることが重要です。",
			importance: "low",
			examples: [
				"基礎: 部分列の概念と問題定義の理解",
				"理論: DP状態設計と遷移式の習得",
				"実装: 基本版から最適化版への発展",
				"応用: 編集距離、diff、配列解析への拡張",
			],
		},
	],
};
