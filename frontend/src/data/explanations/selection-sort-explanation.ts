/**
 * src/data/explanations/selection-sort-explanation.ts
 *
 * 選択ソートの解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "../../components/calculator/CalculationExplanation";

/**
 * 選択ソートの解説データ
 * アルゴリズムの基本概念から実装まで段階的に説明
 */
export const selectionSortExplanation: ExplanationData = {
	calculationType: "selection_sort",
	title: "選択ソートアルゴリズムとは？",
	overview:
		"選択ソートは、配列の中から最小値を「選択」して、ソート済み部分の末尾に移動する操作を繰り返すソートアルゴリズムです。名前の通り「選ぶ」ことに重点を置いたアルゴリズムで、毎回未ソート部分から最小値を選んで正しい位置に配置します。実装がシンプルで理解しやすく、交換回数が最少という特徴があります。",

	sections: [
		{
			id: "basic-concept",
			title: "🎯 基本的な考え方",
			content:
				"選択ソートの考え方は、成績表を整理する作業と似ています。クラスの成績表で点数順に並べ替える際、まず全員の中から最高得点を見つけて1番目に、次に残りから最高得点を見つけて2番目に、という作業を繰り返します。選択ソートも同様に、毎回「残りの中から最小値を選択」して正しい位置に配置します。",
			importance: "high",
			examples: [
				"成績表の整理：全体から最高得点を選んで1位に配置",
				"トランプの整理：山札から最小値を選んで順番に並べる",
				"本棚の整理：残りの本から最も薄いものを選んで左端に配置",
			],
		},

		{
			id: "algorithm-steps",
			title: "📝 アルゴリズムの手順",
			content:
				"選択ソートは以下の手順を繰り返します：1) 未ソート部分全体を調べて最小値を見つける、2) 見つけた最小値を未ソート部分の先頭と交換、3) ソート済み部分を1つ拡張、4) 未ソート部分がなくなるまで繰り返し。この手順により、左から順番に確定した値が並んでいきます。",
			importance: "high",
			examples: [
				"ステップ1：[64,25,12,22,11] → 最小値11を探す",
				"ステップ2：[11,25,12,22,64] → 11と64を交換",
				"ステップ3：[11,12,25,22,64] → 残り[25,12,22,64]から12を選択",
				"ステップ4：繰り返して完成",
			],
		},

		{
			id: "time-complexity",
			title: "⏱️ 時間計算量の分析",
			content:
				"選択ソートの時間計算量は常にO(n²)です。これは、データの初期状態に関係なく、必ず全ての要素を比較する必要があるためです。1回目のパスでn個、2回目でn-1個...と比較を行い、合計でn×(n-1)/2回の比較を実行します。交換回数は最大n-1回と、他のO(n²)アルゴリズムより少ないのが特徴です。",
			formula:
				"時間計算量: O(n²)<br>空間計算量: O(1)<br><br>比較回数: n×(n-1)/2<br>交換回数: 最大n-1回",
			importance: "medium",
			examples: [
				"10個の要素：45回の比較、最大9回の交換",
				"100個の要素：4,950回の比較、最大99回の交換",
				"初期状態に関係なく常に同じ計算量",
			],
		},

		{
			id: "stability-analysis",
			title: "🔄 安定性の特徴",
			content:
				"選択ソートは「不安定ソート」です。これは、同じ値を持つ要素の相対的な順序が保たれない可能性があることを意味します。最小値を見つけて交換する際に、同じ値の要素が入れ替わってしまうことがあります。この性質は、複数のキーでソートする場合に影響を与える可能性があります。",
			importance: "medium",
			examples: [
				"例：[4a, 2, 4b] → [2, 4b, 4a] （4aと4bの順序が変わる）",
				"単純なソートでは問題ないが、複合ソートで影響あり",
				"安定性が必要な場合は他のアルゴリズムを選択",
			],
		},

		{
			id: "advantages",
			title: "✅ 選択ソートの利点",
			content:
				"選択ソートには独特の利点があります。最も重要なのは交換回数の少なさで、最大でもn-1回しか交換を行いません。これは、メモリ書き込みコストが高い環境や、大きなオブジェクトをソートする際に有効です。また、実装がシンプルで理解しやすく、デバッグも容易です。",
			importance: "medium",
			examples: [
				"交換回数最小：大きなデータ構造のソートに有効",
				"実装の簡単さ：コードが短く、理解しやすい",
				"予測可能性：常に同じ手順、同じ計算量",
			],
		},

		{
			id: "comparison-with-others",
			title: "🆚 他のソートアルゴリズムとの比較",
			content:
				"選択ソートを他のO(n²)ソートと比較すると、それぞれに特徴があります。バブルソートは隣接交換で部分的ソートに対応、挿入ソートは安定で部分的ソートに高効率、選択ソートは交換回数最小で一定性能。用途に応じた使い分けが重要です。",
			importance: "high",
			examples: [
				"バブルソート：O(n²)、安定、部分ソートで高速化",
				"挿入ソート：O(n²)、安定、部分ソートで非常に高効率",
				"選択ソート：O(n²)、不安定、交換回数最小",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実際の応用場面",
			content:
				"選択ソートは特定の条件下で実用的です。交換コストが非常に高い場合（大きなオブジェクトや、ディスクI/Oを伴う場合）、メモリ制約が厳しい組み込みシステム、教育目的でのアルゴリズム理解、小規模データの一回限りのソートなどで使用されます。",
			importance: "low",
			examples: [
				"組み込みシステム：メモリ制約下での小規模ソート",
				"大容量データ：交換コストが高い場合の最適化",
				"教育用途：ソートアルゴリズムの基本理解",
			],
		},
	],
};
