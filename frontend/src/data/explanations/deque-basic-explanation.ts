/**
 * src/data/explanations/deque-basic-explanation.ts
 *
 * デック（基本操作）の解説データ
 * 両端操作可能なデータ構造の学習向け
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * デック（基本操作）の解説データ
 * 両端アクセスの原理から実装、応用まで段階的に説明
 */
export const dequeBasicExplanation: ExplanationData = {
	calculationType: "deque_basic",
	title: "デック（Deque）データ構造とは？",
	overview:
		"デック（Double-ended queue）は両端での挿入・削除が可能なデータ構造です。キューとスタックの機能を併せ持ち、先頭・末尾の両方でO(1)時間での操作が可能です。リングバッファや動的配列を使用した効率的な実装により、柔軟なデータ操作を実現します。スライディングウィンドウ、アンドゥ・リドゥ機能、BFSとDFSの統合など、様々なアルゴリズムで重要な役割を果たす汎用性の高いデータ構造です。",

	sections: [
		{
			id: "double-ended-principle",
			title: "↔️ 両端操作の原理",
			content:
				"デックの最大の特徴は、両端（front と rear）での挿入・削除が O(1) 時間で可能なことです。通常のキューは一方向の操作のみですが、デックは双方向の操作により、より柔軟なデータ管理が可能になります。この特性により、スタックとキューの機能を同時に提供でき、単一のデータ構造で複数の用途に対応できます。効率的な実装により、全ての基本操作が定数時間で実行されます。",
			importance: "high",
			examples: [
				"pushFront(): 先頭に要素を追加 - O(1)",
				"pushBack(): 末尾に要素を追加 - O(1)",
				"popFront(): 先頭から要素を削除 - O(1)",
				"popBack(): 末尾から要素を削除 - O(1)",
			],
		},

		{
			id: "basic-operations",
			title: "🔧 基本操作の詳細",
			content:
				"デックの基本操作は8つの主要な操作から構成されます。挿入操作として pushFront、pushBack、削除操作として popFront、popBack があります。確認操作として front、back で両端の要素を非破壊的に参照できます。状態確認として isEmpty、size で現在の状態を把握できます。これらの操作により、キューとしてもスタックとしても使用でき、さらに柔軟な操作パターンを実現できます。",
			importance: "high",
			examples: [
				"キューとして: pushBack, popFront",
				"スタックとして: pushBack, popBack",
				"逆スタックとして: pushFront, popFront",
				"両端確認: front(), back() で非破壊参照",
			],
		},

		{
			id: "implementation-strategies",
			title: "💻 実装戦略",
			content:
				"デックの効率的な実装には複数の戦略があります。動的配列では先頭挿入が O(n) になるため、リングバッファ（循環配列）を使用して両端操作を O(1) で実現します。連結リストでは双方向リストを使用し、先頭と末尾の両方にポインタを保持します。また、複数のブロックを組み合わせたデック実装では、メモリ効率と操作効率の両立を図ります。各実装方法には特有の利点があります。",
			importance: "medium",
			examples: [
				"リングバッファ: 循環配列で効率的な両端操作",
				"双方向リスト: ポインタ操作で動的サイズ",
				"ブロック分割: メモリ効率と操作効率の両立",
				"STL deque: 実用的な高性能実装",
			],
		},

		{
			id: "complexity-analysis",
			title: "⚡ 計算量の分析",
			content:
				"効率的に実装されたデックでは、すべての基本操作が O(1) 時間で実行されます。pushFront、pushBack、popFront、popBack、front、back、isEmpty、size のすべてが定数時間で動作します。空間計算量は格納する要素数 n に対して O(n) です。ランダムアクセスは実装によって異なり、リングバッファでは O(1)、連結リストでは O(n) になります。この効率性により、大量データでも高速な処理が可能です。",
			formula:
				"デックの計算量:<br>基本操作:<br>- pushFront/pushBack: O(1)<br>- popFront/popBack: O(1)<br>- front/back: O(1)<br>- isEmpty/size: O(1)<br><br>ランダムアクセス: O(1) または O(n)<br>空間計算量: O(n)",
			importance: "high",
			examples: [
				"全基本操作: O(1) で高速",
				"大量データ: 要素数に関係なく一定時間",
				"メモリ効率: 要素のみを格納",
				"実装依存: ランダムアクセスの効率",
			],
		},

		{
			id: "real-world-applications",
			title: "🌐 実世界での応用",
			content:
				"デックは様々な実世界のシステムで重要な役割を果たします。Webブラウザの履歴管理では、前後移動の両方向操作に使用されます。テキストエディタのアンドゥ・リドゥ機能では、操作履歴を両端で管理します。ゲーム開発では、プレイヤーの行動履歴や状態管理に活用されます。また、並列処理システムでは、タスクの動的な負荷分散にデックが使用され、効率的なワークスティーリングを実現します。",
			importance: "medium",
			examples: [
				"ブラウザ: 前後移動の履歴管理",
				"エディタ: アンドゥ・リドゥ機能",
				"ゲーム: プレイヤー行動の履歴管理",
				"並列処理: ワークスティーリングキュー",
			],
		},

		{
			id: "algorithms-using-deques",
			title: "🔍 デックを使用するアルゴリズム",
			content:
				"デックは多くの重要なアルゴリズムで活用されています。スライディングウィンドウ最大値問題では、モノトニックデックを使用して効率的に解決します。0-1 BFS では、重みが0の辺と1の辺に応じてデックの前後を使い分けます。A*探索では、ヒューリスティック値に応じて優先度を調整したキューとして使用されます。また、双方向BFSでは、探索の効率化にデックが重要な役割を果たします。",
			importance: "medium",
			examples: [
				"スライディングウィンドウ: 区間最大値の効率的計算",
				"0-1 BFS: 重み付きグラフの最短経路",
				"A*探索: ヒューリスティック探索の実装",
				"双方向BFS: 探索効率の改善",
			],
		},

		{
			id: "design-patterns",
			title: "🏗️ デザインパターンでの活用",
			content:
				"デックは様々なデザインパターンで活用されます。Command パターンでは、実行・取り消し可能なコマンドをデックで管理し、柔軟なアンドゥ・リドゥ機能を実現します。Observer パターンでは、イベントの順序管理にデックを使用します。Producer-Consumer パターンでは、複数の生産者・消費者間のデータ交換にデックが活用されます。これらのパターンにより、保守性の高いソフトウェア設計が可能になります。",
			importance: "low",
			examples: [
				"Command: アンドゥ・リドゥの実装",
				"Observer: イベント順序の管理",
				"Producer-Consumer: データ交換の調整",
				"Memento: 状態履歴の効率的管理",
			],
		},

		{
			id: "performance-optimization",
			title: "🚀 性能最適化",
			content:
				"デックの性能最適化には複数のアプローチがあります。メモリの局所性を活用するため、ブロック単位でのメモリ管理を行います。プリフェッチングにより次のブロックを先読みし、キャッシュミスを削減します。また、操作パターンに応じて最適な実装を選択し、例えば頻繁なランダムアクセスが必要な場合は配列ベース、動的サイズ変更が多い場合は連結リストベースを採用します。",
			importance: "low",
			examples: [
				"ブロック管理: メモリ局所性の向上",
				"プリフェッチング: キャッシュ効率の改善",
				"実装選択: 用途に応じた最適化",
				"操作最適化: アクセスパターンの分析",
			],
		},

		{
			id: "common-mistakes",
			title: "⚠️ よくある間違いと注意点",
			content:
				"デックの使用において、いくつかの典型的な間違いがあります。空のデックからの削除操作は例外処理が必要です。サイズの管理を怠ると、意図しないメモリ使用量の増加が起こります。マルチスレッド環境では、適切な同期処理なしに複数スレッドから操作すると競合状態が発生します。また、ランダムアクセスを頻繁に行う場合は、配列の方が適している場合もあります。",
			importance: "medium",
			examples: [
				"空デックエラー: 削除前の isEmpty() チェック",
				"メモリ管理: 不要な要素の適切な削除",
				"競合状態: マルチスレッドでの同期処理",
				"用途選択: ランダムアクセス頻度の考慮",
			],
		},

		{
			id: "learning-progression",
			title: "📚 学習の進め方",
			content:
				"デックの学習は、まず基本概念と両端操作の理解から始めます。キューとスタックの復習後、デックの追加機能を学習します。次に実装方法を理解し、リングバッファや双方向リストでの実装を比較します。応用として、スライディングウィンドウやBFS変形などのアルゴリズムでの使用例を学習します。最終的には、実際のシステム設計での活用方法を習得し、適切なデータ構造選択ができるようになります。",
			importance: "low",
			examples: [
				"基礎: 両端操作と基本概念の理解",
				"実装: リングバッファと連結リストの比較",
				"応用: アルゴリズムでの活用例",
				"設計: 実システムでの適用方法",
			],
		},
	],
};
