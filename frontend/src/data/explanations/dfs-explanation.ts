/**
 * src/data/explanations/dfs-explanation.ts
 *
 * 深さ優先探索（DFS）の解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "../../components/calculator/CalculationExplanation";

/**
 * 深さ優先探索（DFS）の解説データ
 * グラフアルゴリズムの基本として、再帰・スタック・グラフ理論の理解を深める
 */
export const dfsExplanation: ExplanationData = {
	calculationType: "depth_first_search",
	title: "深さ優先探索（DFS）アルゴリズムとは？",
	overview:
		"深さ優先探索（Depth-First Search, DFS）は、グラフや木構造を探索する基本的なアルゴリズムです。現在のノードから可能な限り深く進み、行き止まりに達したら戻って他の経路を探索する方法です。再帰的な実装が直感的で、スタックを使った反復実装も可能です。O(V+E)の時間計算量でグラフ全体を探索でき、経路探索、連結性判定、トポロジカルソートなど多くのグラフ問題の基礎となる重要なアルゴリズムです。",

	sections: [
		{
			id: "dfs-concept",
			title: "🌲 深さ優先探索の基本概念",
			content:
				"深さ優先探索は「深く、深く」を合言葉とするグラフ探索アルゴリズムです。スタート地点から始めて、隣接する未訪問ノードがある限り、常により深い方向に進み続けます。行き止まりに達すると、直前の分岐点まで戻って（バックトラック）、他の未探索の経路を探索します。この過程を全てのノードが訪問されるまで繰り返します。人間が迷路を探索する時の「右手法」に似ており、系統的で確実な探索方法です。",
			importance: "high",
			examples: [
				"迷路の探索：壁にぶつかるまで直進し、行き止まりで引き返す",
				"ファイルシステム：フォルダの最深部まで降りてから次のフォルダへ",
				"家系図の調査：一つの血筋を最後まで辿ってから別の血筋へ",
				"ウェブクローリング：リンクを深く辿ってから別のページへ",
				"パズルの解法：一つの可能性を最後まで試してから別の手を考える",
			],
		},

		{
			id: "graph-representation",
			title: "📊 グラフの表現方法",
			content:
				"DFSを実装する前に、グラフをコンピュータ上でどう表現するかが重要です。主な方法は隣接リスト（推奨）と隣接行列です。隣接リストは各ノードに接続されたノードのリストを保持し、メモリ効率が良く実装も簡単です。隣接行列は全ノード間の接続をマトリックスで表現し、接続の確認は高速ですがメモリを多く使用します。グラフには有向グラフ（一方通行）と無向グラフ（双方向）があり、DFSはどちらにも適用できます。",
			importance: "high",
			examples: [
				"隣接リスト例：{A: [B, C], B: [D], C: [D], D: []}",
				"無向グラフ：A-B間に辺があれば、A→BとB→A両方向に記録",
				"有向グラフ：A→Bの辺は、AのリストにのみBを記録",
				"重み付きグラフ：各辺に距離やコストを付加",
				"自己ループ：ノードが自分自身に接続する場合",
			],
		},

		{
			id: "recursive-implementation",
			title: "🔄 再帰による実装",
			content:
				"DFSの再帰実装は非常に直感的で理解しやすいです。dfs(node, visited)関数で、①現在のノードを訪問済みにマーク、②隣接する未訪問ノードに対して再帰呼び出し、という2ステップで実現されます。再帰の性質により、深い方向への探索が自然に実現され、関数の戻りでバックトラッキングが自動的に行われます。ただし、深いグラフではスタックオーバーフローのリスクがあるため、反復実装も重要です。",
			importance: "high",
			examples: [
				"基本構造：dfs(node) { visit(node); for each neighbor: dfs(neighbor) }",
				"訪問管理：visited配列やSetで重複訪問を防止",
				"終了条件：全隣接ノードが訪問済みで自然に終了",
				"バックトラック：関数の戻りで自動的に実現",
				"深度制限：無限ループを防ぐため最大深度を設定",
			],
		},

		{
			id: "iterative-implementation",
			title: "📚 スタックによる反復実装",
			content:
				"DFSの反復実装では明示的なスタック（後入れ先出し）を使用します。①開始ノードをスタックにプッシュ、②スタックが空でない間、③トップをポップして訪問、④その隣接未訪問ノードをスタックにプッシュ、を繰り返します。再帰実装と比べて、スタックオーバーフローを回避でき、大きなグラフでも安全に動作します。また、探索過程の制御や一時停止も容易で、実用的なアプリケーションでよく使用されます。",
			importance: "medium",
			examples: [
				"スタック操作：push（追加）、pop（取り出し）",
				"LIFO原理：Last In, First Out - 最後に入れたものを最初に取り出す",
				"初期化：start nodeをstackにpush",
				"メインループ：while stack is not empty",
				"隣接ノード処理：未訪問なら全てスタックに追加",
			],
		},

		{
			id: "time-space-complexity",
			title: "⏱️ 計算量の分析",
			content:
				"DFSの時間計算量はO(V + E)です。Vは頂点数、Eは辺数で、各頂点を1回ずつ訪問し、各辺を1回ずつチェックするためです。空間計算量はO(V)で、visitedセット（O(V)）と再帰スタックまたは明示的スタック（最悪O(V)）が必要です。この効率性により、大規模なグラフでも実用的な時間で探索が可能です。幅優先探索（BFS）と同じ時間計算量ですが、メモリ使用パターンが異なります。",
			formula:
				"時間計算量: O(V + E)<br>空間計算量: O(V)<br><br>詳細分析:<br>頂点訪問: 各頂点を1回 = O(V)<br>辺のチェック: 各辺を1回 = O(E)<br>visited配列: O(V)<br>スタック/再帰: 最悪O(V)の深さ",
			importance: "medium",
			examples: [
				"完全グラフ（n個の頂点が全て接続）：O(n²)",
				"線形グラフ（一本道）：O(n)",
				"木構造（n個のノード）：O(n)",
				"格子グラフ（m×nグリッド）：O(mn)",
				"実用的性能：数千〜数万ノードまで高速",
			],
		},

		{
			id: "applications",
			title: "🔧 実用的な応用分野",
			content:
				"DFSは多くの重要なアルゴリズムの基礎となっています。連結性の判定（グラフが一つに繋がっているか）、強連結成分の検出、トポロジカルソート（依存関係のある処理の順序決定）、橋や関節点の発見などです。また、迷路の解法、ゲームのAI（ゲーム木の探索）、コンパイラの構文解析、ウェブクローリング、ファイルシステムの探索など、身近なアプリケーションでも広く使用されています。",
			importance: "medium",
			examples: [
				"迷路の解法：ゴールまでの経路を発見",
				"SNSの友達関係：ユーザー間の繋がりを調査",
				"依存関係の解析：ソフトウェアモジュールの読み込み順序",
				"ウェブクローリング：ウェブサイトの全ページを巡回",
				"ゲームAI：将棋やチェスの手順を先読み",
			],
		},

		{
			id: "dfs-vs-bfs",
			title: "🔄 深さ優先探索 vs 幅優先探索",
			content:
				"DFSとBFS（幅優先探索）は対照的なグラフ探索戦略です。DFSは深く掘り下げてからバックトラック、BFSは同じ距離のノードを幅広く探索してから次の距離へ進みます。DFSはメモリ効率が良く、解の存在判定や経路発見に適します。BFSは最短経路の発見に適し、レベルごとの探索が必要な場合に有効です。用途に応じて適切な手法を選択することが重要です。",
			importance: "medium",
			examples: [
				"DFS：深く→浅く、スタック使用、メモリ効率良",
				"BFS：幅広く→深く、キュー使用、最短経路発見",
				"迷路：DFSは解を見つける、BFSは最短解を見つける",
				"SNS：DFSは遠い友達を発見、BFSは近い友達から順番に",
				"ファイル検索：DFSは深いフォルダ優先、BFSは浅いフォルダ優先",
			],
		},

		{
			id: "common-pitfalls",
			title: "⚠️ よくある間違いと注意点",
			content:
				"DFS実装でよくある間違いには、①訪問済みチェックの忘れ（無限ループ）、②有向グラフと無向グラフの混同、③スタックオーバーフローの未考慮、④再帰の終了条件の設定ミスなどがあります。特に循環するグラフでは訪問済み管理が必須です。また、大きなグラフでは再帰の深さに注意し、必要に応じて反復実装を検討することが重要です。デバッグ時は探索順序を可視化すると理解が深まります。",
			importance: "medium",
			examples: [
				"無限ループ：visited チェックを忘れて同じノードを何度も訪問",
				"スタックオーバーフロー：深すぎる再帰でメモリ不足",
				"グラフ構造の誤解：有向と無向の混同",
				"終了条件の設定ミス：全ノードを訪問できない",
				"メモリリーク：大きなvisited配列の適切な管理",
			],
		},

		{
			id: "optimization-techniques",
			title: "🚀 最適化と高速化技法",
			content:
				"DFSの性能を向上させる技法には、①隣接リストの事前ソート（探索順序の制御）、②早期終了条件の設定（目標発見時の探索停止）、③メモ化（同じ部分グラフの結果キャッシュ）、④並列処理（複数の経路を同時探索）などがあります。また、アプリケーション固有の制約を活用した枝刈り（prune）や、ヒューリスティック（経験則）を組み合わせることで、大幅な高速化が可能です。",
			importance: "low",
			examples: [
				"早期終了：目標ノードを発見したら即座に探索終了",
				"枝刈り：明らかに無駄な経路は探索しない",
				"メモ化：計算済みの結果を記録して再利用",
				"並列化：複数の開始点から同時にDFSを実行",
				"ヒューリスティック：経験則で探索順序を最適化",
			],
		},
	],
};
