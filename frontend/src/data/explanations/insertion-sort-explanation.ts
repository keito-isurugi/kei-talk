/**
 * src/data/explanations/insertion-sort-explanation.ts
 *
 * 挿入ソートの解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * 挿入ソートの解説データ
 * アルゴリズムの基本概念から実装まで段階的に説明
 */
export const insertionSortExplanation: ExplanationData = {
	calculationType: "insertion_sort",
	title: "挿入ソートアルゴリズムとは？",
	overview:
		"挿入ソートは、配列の各要素を既にソートされた部分の適切な位置に「挿入」するソートアルゴリズムです。トランプのカードを手札に並べる作業と同じ原理で、新しいカードを受け取るたびに、適切な位置を見つけて挿入します。部分的にソートされた配列では非常に高効率で、安定ソートの特性も持っています。",

	sections: [
		{
			id: "basic-concept",
			title: "🎯 基本的な考え方",
			content:
				"挿入ソートは、トランプゲームで手札を整理する作業と全く同じです。最初は1枚のカードから始まり、新しいカードを受け取るたびに、既に並んでいるカードの適切な位置を見つけて挿入します。既に並んでいる部分は常にソートされた状態を保ち、一枚ずつ整理されたエリアを拡張していきます。",
			importance: "high",
			examples: [
				"トランプの手札整理：新しいカードを適切な位置に挿入",
				"図書館の本の整理：新しい本を適切な棚の位置に挿入",
				"成績表の作成：新しい生徒の成績を適切な順位に挿入",
			],
		},

		{
			id: "algorithm-steps",
			title: "📝 アルゴリズムの手順",
			content:
				"挿入ソートは以下の手順を繰り返します：1) 2番目の要素から開始（1番目は既にソート済みと見なす）、2) 現在の要素を一時的に保存、3) 既ソート部分の右端から左へ比較し、より大きな要素を右にシフト、4) 適切な位置が見つかったら、保存した要素を挿入、5) 次の要素へ進む。この手順により、左から順番にソートされたエリアが拡張されます。",
			importance: "high",
			examples: [
				"ステップ1：[5,2,4,6,1,3] → 要素2を[5]に挿入",
				"ステップ2：[2,5,4,6,1,3] → 要素4を[2,5]に挿入",
				"ステップ3：[2,4,5,6,1,3] → 要素6を[2,4,5]に挿入",
				"ステップ4：同様に最後まで繰り返し",
			],
		},

		{
			id: "time-complexity",
			title: "⏱️ 時間計算量の分析",
			content:
				"挿入ソートの時間計算量は入力データの状態に大きく依存します。最良ケース（既にソート済み）ではO(n)、最悪ケース（逆順）ではO(n²)、平均的なケースでもO(n²)となります。ただし、部分的にソートされた配列では実際の実行時間は大幅に改善され、実用的な性能を発揮します。",
			formula:
				"時間計算量: O(n) ～ O(n²)<br>空間計算量: O(1)<br><br>最良ケース: O(n) 比較、0回シフト<br>最悪ケース: O(n²) 比較、O(n²)回シフト",
			importance: "medium",
			examples: [
				"ソート済み配列：n-1回の比較のみ、シフトなし",
				"逆順配列：n²/2回の比較、n²/2回のシフト",
				"ランダム配列：平均的にO(n²)だが定数因子が小さい",
			],
		},

		{
			id: "stability-analysis",
			title: "🔄 安定性の特徴",
			content:
				"挿入ソートは「安定ソート」です。これは、同じ値を持つ要素の相対的な順序が保たれることを意味します。要素を挿入する際、既存の同じ値の要素より後ろに配置されるため、元の順序が維持されます。この特性は、複数のキーでソートする場合や、データの一意性を保つ必要がある場合に重要です。",
			importance: "medium",
			examples: [
				"例：[4a, 2, 4b, 1] → [1, 2, 4a, 4b] （4aと4bの順序が保持）",
				"複合ソート：名前順→年齢順のような段階的ソートが可能",
				"データベース処理：主キーの順序を保ったままソート",
			],
		},

		{
			id: "adaptive-nature",
			title: "🚀 適応的特性",
			content:
				"挿入ソートの最大の特徴は「適応的」であることです。入力データが部分的にソートされている場合、アルゴリズムは自動的にそれを検知し、大幅に高速化します。既にソートされた部分では比較回数が最小限に抑えられ、理論上のO(n²)よりもはるかに高性能を発揮します。",
			importance: "high",
			examples: [
				"ほぼソート済み：わずかな比較とシフトで完了",
				"新要素の追加：既存のソート済み配列に新要素を効率的に挿入",
				"リアルタイム処理：データが逐次到着する場合に最適",
			],
		},

		{
			id: "advantages",
			title: "✅ 挿入ソートの利点",
			content:
				"挿入ソートには多くの実用的な利点があります。実装が簡単で理解しやすく、安定ソートであり、小規模データやほぼソート済みデータで高効率、オンラインアルゴリズム（データが逐次到着）として使用可能、メモリ使用量が定数、など実際のプログラミングで有用な特性を多く持っています。",
			importance: "medium",
			examples: [
				"小規模データ：配列サイズ50以下では非常に効率的",
				"オンライン処理：ストリーミングデータのリアルタイムソート",
				"ハイブリッドソート：クイックソートなどの補助アルゴリズム",
			],
		},

		{
			id: "comparison-with-others",
			title: "🆚 他のソートアルゴリズムとの比較",
			content:
				"O(n²)アルゴリズムの中で、挿入ソートは実用性が最も高いとされています。バブルソートは理解しやすいが非効率、選択ソートは交換回数が少ないが適応性なし、挿入ソートは安定で適応的、実用的という特徴があります。実際、多くの高速ソートアルゴリズムが小規模部分で挿入ソートを使用しています。",
			importance: "high",
			examples: [
				"バブルソート：O(n²)、安定、実用性低い",
				"選択ソート：O(n²)、不安定、交換回数最小",
				"挿入ソート：O(n²)、安定、適応的、実用的",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実際の応用場面",
			content:
				"挿入ソートは現代のプログラミングでも広く使用されています。多くの標準ライブラリのソート関数が小規模配列で挿入ソートを使用し、オンラインゲームのリアルタイムランキング、データベースの増分ソート、組み込みシステムでの効率的なソートなど、様々な場面で活躍しています。",
			importance: "low",
			examples: [
				"標準ライブラリ：Timsort、Introsortの構成要素",
				"リアルタイムシステム：ゲームのスコアランキング更新",
				"データ分析：小規模データセットの前処理",
			],
		},
	],
};
