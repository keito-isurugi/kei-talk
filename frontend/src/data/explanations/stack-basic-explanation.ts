/**
 * src/data/explanations/stack-basic-explanation.ts
 *
 * スタック（基本操作）の解説データ
 * LIFO原理とスタックデータ構造の学習向け
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * スタック（基本操作）の解説データ
 * LIFO原理の基本から実装、応用まで段階的に説明
 */
export const stackBasicExplanation: ExplanationData = {
	calculationType: "stack_basic",
	title: "スタック（Stack）データ構造とは？",
	overview:
		"スタックは「Last In, First Out（LIFO）」原理に基づくデータ構造です。最後に追加された要素が最初に取り出される性質を持ち、日常生活の「皿の重ね」や「本の積み重ね」と同じ概念です。プログラミングでは、関数呼び出しの管理、式の評価、アンドゥ機能、深さ優先探索（DFS）など様々な場面で使用されます。基本操作（push、pop、top）がすべてO(1)時間で実行でき、シンプルで効率的なデータ管理を実現します。",

	sections: [
		{
			id: "lifo-principle",
			title: "📚 LIFO原理の理解",
			content:
				"LIFO（Last In, First Out）は「最後に入れたものが最初に出てくる」という原理です。日常生活では、皿の重ね、本の積み重ね、トレイの重ね置きなどで見られる概念です。スタックでは、要素の追加と取り出しが同じ端（top/先頭）で行われます。この制約により、逆順アクセスや一時的な保存と復元、再帰的な処理の管理などが自然に実現できます。コンピュータシステムの多くの場面でこの原理が活用されています。",
			importance: "high",
			examples: [
				"皿の重ね: 最後に置いた皿が最初に取られる",
				"アンドゥ機能: 最後の操作が最初にアンドゥされる",
				"関数呼び出し: 最後に呼ばれた関数が最初に終了する",
				"ブラウザ履歴: 最後に訪問したページから戻る",
			],
		},

		{
			id: "basic-operations",
			title: "🔧 基本操作の詳細",
			content:
				"スタックの基本操作は主に5つあります。push（要素追加）は先頭に新しい要素を追加し、pop（要素取出）は先頭から要素を取り出します。top/peek（先頭確認）は先頭要素を削除せずに確認し、isEmpty（空判定）とsize（要素数取得）は状態の確認に使用します。これらの操作はすべてO(1)時間で実行でき、効率的なデータ管理を可能にします。エラーハンドリング（空スタックからのpopなど）も重要な考慮点です。",
			importance: "high",
			examples: [
				"push(5): 先頭に5を追加 → [5,3,2,1]",
				"pop(): 先頭要素5を取り出し → [3,2,1]",
				"top(): 先頭要素3を確認（削除なし）",
				"isEmpty(): スタックが空かどうかを判定",
			],
		},

		{
			id: "implementation-details",
			title: "💻 実装における考慮点",
			content:
				"スタックの実装には主に配列ベースと連結リストベースの2つの方法があります。配列ベースは実装が簡単で、動的配列（JavaScript の Array など）を使用すると push/pop が O(1) で実行できます。連結リストベースは動的サイズで メモリ効率が良く、先頭への追加・削除が自然に実装できます。また、固定サイズのスタックやスレッドセーフな実装、アンダーフロー/オーバーフローの対策など、用途に応じた最適化が重要です。",
			importance: "medium",
			examples: [
				"配列実装: push()とpop()で効率的な操作",
				"連結リスト実装: 動的サイズで先頭操作が自然",
				"固定サイズ: 組み込みシステムでのメモリ制御",
				"スレッドセーフ: マルチスレッド環境での同期",
			],
		},

		{
			id: "complexity-analysis",
			title: "⚡ 計算量の分析",
			content:
				"スタックのすべての基本操作は O(1) 時間で実行されます。push、pop、top、isEmpty、size のすべてが定数時間で動作し、要素数に関係なく一定時間で処理が完了します。空間計算量は格納する要素数 n に対して O(n) です。この効率性により、大量のデータや深い再帰処理でも高速に動作します。また、アクセスパターンが予測可能なため、キャッシュ効率も良好です。",
			formula:
				"スタックの計算量：<br>時間計算量:<br>- push: O(1)<br>- pop: O(1)<br>- top/peek: O(1)<br>- isEmpty/size: O(1)<br><br>空間計算量: O(n) (n = 要素数)",
			importance: "high",
			examples: [
				"一定時間操作: データ量に関係なく高速",
				"深い再帰: 数千レベルの関数呼び出しでも効率的",
				"大量データ: 数百万要素でも基本操作は瞬時",
				"予測可能性: 処理時間が一定でリアルタイム対応",
			],
		},

		{
			id: "real-world-applications",
			title: "🌐 実世界での応用",
			content:
				"スタックは様々な実世界のシステムで基盤技術として使用されています。プログラミング言語では関数呼び出しの管理（コールスタック）や式の評価に不可欠です。コンパイラでは構文解析や中間コード生成に使用されます。テキストエディタのアンドゥ機能、Webブラウザの履歴管理、ゲームの状態管理など、ユーザーインターフェースでも広く活用されています。オペレーティングシステムでは割り込み処理やメモリ管理にも使用されます。",
			importance: "medium",
			examples: [
				"関数呼び出し: プログラムの実行管理",
				"コンパイラ: 構文解析と式の評価",
				"エディタ: アンドゥ・リドゥ機能",
				"ブラウザ: 戻るボタンと履歴管理",
			],
		},

		{
			id: "expression-evaluation",
			title: "🔢 式の評価での活用",
			content:
				"スタックは数式の評価において重要な役割を果たします。中置記法から後置記法（逆ポーランド記法）への変換、後置記法の計算、括弧の対応チェックなどで使用されます。演算子の優先度処理や括弧のネストした構造の管理が自然に実現できます。この応用により、計算機や数式処理システム、プログラミング言語の式評価エンジンなどが構築されています。",
			importance: "medium",
			examples: [
				"中置→後置: (3+4)*2 → 3 4 + 2 *",
				"後置計算: 3 4 + 2 * → 7 2 * → 14",
				"括弧チェック: ()[]{}の対応確認",
				"演算子優先: +,-よりも*,/を先に処理",
			],
		},

		{
			id: "algorithms-using-stacks",
			title: "🔍 スタックを使用するアルゴリズム",
			content:
				"スタックは多くの重要なアルゴリズムの基礎となっています。深さ優先探索（DFS）では、訪問すべきノードをスタックで管理することで、グラフやツリーの探索を実現します。再帰アルゴリズムの反復版への変換では、関数呼び出しスタックを明示的にスタックで管理します。バックトラッキング、トポロジカルソート、強連結成分の検出など、多くのグラフアルゴリズムでスタックが活用されています。",
			importance: "medium",
			examples: [
				"DFS: グラフの深さ優先探索",
				"バックトラッキング: 解の空間探索",
				"再帰→反復: スタックで関数呼び出しを模拟",
				"強連結成分: Tarjanのアルゴリズム",
			],
		},

		{
			id: "call-stack-management",
			title: "📞 コールスタックの管理",
			content:
				"プログラミング言語の実行時システムでは、関数呼び出しの管理にスタックが使用されます。各関数呼び出しでスタックフレームが作成され、ローカル変数、引数、戻りアドレスが保存されます。再帰関数では、各再帰呼び出しが新しいスタックフレームを作成し、基底条件に達すると逆順で関数が終了していきます。スタックオーバーフローの理解や、tail call optimizationなどの最適化もこの概念に基づいています。",
			importance: "medium",
			examples: [
				"関数呼び出し: 引数とローカル変数の管理",
				"再帰: 各呼び出しレベルでの状態保持",
				"例外処理: catch文への制御移転",
				"スタックオーバーフロー: 深すぎる再帰の検出",
			],
		},

		{
			id: "common-mistakes",
			title: "⚠️ よくある間違いと注意点",
			content:
				"スタックの実装と使用において、いくつかの典型的な間違いがあります。空のスタックからのpop操作は例外処理が必要です。スタックオーバーフローを防ぐため、深い再帰や大量のデータに対する制限チェックが重要です。マルチスレッド環境では適切な同期処理が必要です。また、メモリ管理では、不要になったオブジェクトへの参照を適切にクリアしてメモリリークを防ぐ必要があります。",
			importance: "medium",
			examples: [
				"空スタックエラー: pop前のisEmpty()チェック",
				"スタックオーバーフロー: 再帰深度の制限",
				"メモリリーク: 不要オブジェクトの参照クリア",
				"競合状態: マルチスレッドでの同期処理",
			],
		},

		{
			id: "learning-progression",
			title: "📚 学習の進め方",
			content:
				"スタックの学習は、まず基本概念とLIFO原理の理解から始めます。日常生活の例（皿の重ねなど）を通じて概念を把握した後、簡単な配列実装を行います。次に、式の評価や括弧マッチングなどの応用問題に取り組み、実際の使用例を理解します。その後、DFSやバックトラッキングなどのアルゴリズムでの活用を学習し、最終的には関数呼び出しやコンパイラでの使用など、システムレベルでの理解を深めます。",
			importance: "low",
			examples: [
				"基礎: LIFO原理と基本操作の理解",
				"実装: 配列と連結リストでの実装比較",
				"応用: 式評価、括弧マッチング、DFS",
				"発展: コンパイラ、システムレベルでの活用",
			],
		},
	],
};
