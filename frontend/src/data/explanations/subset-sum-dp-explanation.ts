/**
 * src/data/explanations/subset-sum-dp-explanation.ts
 *
 * 部分和問題（動的計画法）の解説データ
 * 二次元DPと状態設計の学習向け
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * 部分和問題（動的計画法）の解説データ
 * 二次元DPの基本概念から効率的な実装まで段階的に説明
 */
export const subsetSumDpExplanation: ExplanationData = {
	calculationType: "subset_sum_dp",
	title: "部分和問題（動的計画法）アルゴリズムとは？",
	overview:
		"部分和問題は、与えられた配列の部分集合でターゲットの和を作れるかを判定する古典的な問題です。動的計画法による解法では、二次元DPテーブルを使って効率的に解を求めます。この問題は動的計画法の学習における重要な題材であり、ナップサック問題などのより複雑な最適化問題への基礎となります。",

	sections: [
		{
			id: "problem-definition",
			title: "🎯 問題の定義",
			content:
				"部分和問題は、正の整数からなる配列とターゲット値が与えられたとき、配列の部分集合の和がターゲット値と一致するものが存在するかを判定する問題です。例えば、配列[2,3,7,8,10]とターゲット11が与えられた場合、部分集合{3,8}の和が11になるため、答えは「存在する」となります。この問題は組み合わせ最適化の基本的な例で、計算機科学の多くの分野で応用されています。",
			importance: "high",
			examples: [
				"配列[2,3,7,8,10]、ターゲット11 → {3,8}で解決可能",
				"配列[1,2,3]、ターゲット4 → {1,3}で解決可能",
				"配列[2,4,6]、ターゲット5 → 解決不可能",
				"配列[5]、ターゲット5 → {5}で解決可能",
			],
		},

		{
			id: "naive-approach-problems",
			title: "🔍 全探索の問題点",
			content:
				"部分和問題を全探索で解く場合、配列の各要素について「選ぶ/選ばない」の2択があるため、2^n通りの部分集合をすべて調べる必要があります。要素数が増えると計算時間が指数的に増加し、実用的でなくなります。例えば20要素の配列では約100万通り、30要素では約10億通りの組み合わせを調べる必要があり、現実的な時間では解けなくなります。",
			importance: "high",
			examples: [
				"5要素: 2^5 = 32通り",
				"10要素: 2^10 = 1,024通り",
				"20要素: 2^20 = 1,048,576通り",
				"30要素: 2^30 = 1,073,741,824通り",
			],
		},

		{
			id: "dp-state-design",
			title: "📊 DPの状態設計",
			content:
				"動的計画法では、問題を部分問題に分解し、各部分問題の解を効率的に求めます。部分和問題では、dp[i][j]を「配列の最初のi個の要素を使って和jを作ることができるか」として定義します。この状態設計により、各要素について「含める/含めない」の判断を体系的に行えます。最終的な答えはdp[n][target]に格納されます。",
			importance: "high",
			examples: [
				"dp[0][0] = true （空集合の和は0）",
				"dp[i][0] = true （空集合は常に和0を作れる）",
				"dp[i][j] = 最初のi個の要素で和jを作れるか",
				"dp[n][target] = 全要素を考慮した最終答え",
			],
		},

		{
			id: "state-transition",
			title: "🔄 状態遷移の仕組み",
			content:
				"各セルdp[i][j]の値は、前の行の情報から決定されます。i番目の要素をarr[i-1]とすると、dp[i][j] = dp[i-1][j] OR dp[i-1][j-arr[i-1]]となります。左項は「i番目の要素を含めない場合」、右項は「i番目の要素を含める場合」を表します。右項はj >= arr[i-1]の場合のみ有効です。この遷移により、すべての可能性を効率的に探索できます。",
			importance: "high",
			examples: [
				"要素3を考慮、ターゲット5の場合",
				"含めない: dp[i-1][5]の値をそのまま使用",
				"含める: dp[i-1][2]の値を使用（5-3=2）",
				"結果: 両方のうち一つでもtrueなら可能",
			],
		},

		{
			id: "table-construction",
			title: "🏗️ テーブルの構築過程",
			content:
				"DPテーブルは行ごと（要素ごと）に構築していきます。まず0行目と0列目をベースケースで初期化し、その後1行目から順番に各セルを計算します。各行の計算では、現在の要素を含める場合と含めない場合の両方を考慮し、どちらかで和を作れる場合にtrueを設定します。この過程により、最終的にすべての部分問題の解が得られます。",
			importance: "medium",
			examples: [
				"初期化: 0列目をすべてtrue（空集合）",
				"行ごとの処理: 要素を一つずつ考慮",
				"セルごとの計算: 含める/含めないを判断",
				"最終結果: 右下のセルに答えが格納",
			],
		},

		{
			id: "complexity-analysis",
			title: "⚡ 計算量の分析",
			content:
				"動的計画法による部分和問題の解法は、時間計算量O(n×S)、空間計算量O(n×S)です（nは要素数、Sはターゲット値）。これは全探索のO(2^n)と比べて大幅な改善です。ただし、ターゲット値が非常に大きい場合は「疑似多項式時間」となり、実際には指数時間になる可能性があります。実用的には、ターゲット値が合理的な範囲内であれば十分効率的です。",
			formula:
				"時間計算量: O(n×S)<br>空間計算量: O(n×S)<br><br>比較例（n=20, S=100）:<br>全探索: 2^20 = 1,048,576回<br>DP: 20×100 = 2,000回<br><br>改善率: 約524倍の高速化",
			importance: "high",
			examples: [
				"小さなターゲット: 非常に効率的",
				"大きなターゲット: 疑似多項式時間の注意",
				"要素数の増加: 線形的な計算時間の増加",
				"全探索との比較: 劇的な改善を実現",
			],
		},

		{
			id: "solution-reconstruction",
			title: "🔍 解の復元",
			content:
				"DPテーブルからは部分集合の存在だけでなく、実際の部分集合も復元できます。dp[n][target]からバックトラックして、各段階で要素を含めたかどうかを判断します。dp[i][j] != dp[i-1][j]の場合、i番目の要素が含まれています。このようにして、条件を満たす具体的な部分集合を構築できます。",
			importance: "medium",
			examples: [
				"バックトラック: 右下から左上へ遡る",
				"要素の判定: 上の行との値の比較",
				"部分集合の構築: 含まれる要素を記録",
				"複数解の存在: 最初に見つかった解を返す",
			],
		},

		{
			id: "optimization-techniques",
			title: "🚀 最適化技法",
			content:
				"基本的な二次元DPは空間効率を改善できます。各行の計算では前の行の情報のみ必要なため、一次元配列で実装可能です。また、ターゲット値から逆順に更新することで、同一配列内での更新競合を避けられます。さらに、要素の和がターゲットより小さい場合の早期終了や、重複要素のグループ化などの最適化も可能です。",
			importance: "low",
			examples: [
				"空間最適化: O(S)の一次元配列",
				"逆順更新: 更新競合の回避",
				"早期終了: 不可能ケースの検出",
				"前処理: ソートや重複除去",
			],
		},

		{
			id: "real-world-applications",
			title: "🌍 実世界での応用",
			content:
				"部分和問題は多くの実世界の問題に応用されます。ナップサック問題、分割問題（配列を等しい和に分割）、硬貨の組み合わせ問題、予算制約下でのリソース配分など、様々な最適化問題の基礎となります。また、暗号学におけるナップサック暗号や、データ分析での特徴選択問題にも関連があります。",
			importance: "low",
			examples: [
				"ナップサック問題: 価値と重量の制約",
				"予算配分: 限られた予算での最適化",
				"データ分析: 特徴の組み合わせ選択",
				"ゲーム理論: 戦略の組み合わせ",
			],
		},

		{
			id: "learning-progression",
			title: "📚 学習の進め方",
			content:
				"部分和問題は二次元DPの入門として最適です。まず小さな例で手計算によりテーブルの構築過程を理解し、次に実装して動作を確認します。その後、ナップサック問題や最長共通部分列問題など、より複雑な二次元DP問題に挑戦します。状態設計の考え方を身につけることで、新しい問題にも応用できるようになります。",
			importance: "low",
			examples: [
				"入門: 部分和問題（二次元DP基礎）",
				"基礎: ナップサック問題（価値の概念）",
				"中級: 最長共通部分列（文字列DP）",
				"上級: 区間DP、状態圧縮DP",
			],
		},
	],
};
