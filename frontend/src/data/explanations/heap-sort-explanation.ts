/**
 * src/data/explanations/heap-sort-explanation.ts
 *
 * ヒープソートの解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "../../components/calculator/CalculationExplanation";

/**
 * ヒープソートの解説データ
 * アルゴリズムの基本概念から実装まで段階的に説明
 */
export const heapSortExplanation: ExplanationData = {
	calculationType: "heap_sort",
	title: "ヒープソートアルゴリズムとは？",
	overview:
		"ヒープソートは、ヒープ（完全二分木で親が子より大きい/小さいという条件を満たすデータ構造）を利用したソートアルゴリズムです。配列をヒープ構造に変換し、最大値（最小値）を順次取り出すことでソートを実現します。常にO(n log n)の時間計算量を保証し、追加メモリをほとんど必要としないインプレースソートです。選択ソートの効率的な改良版とも考えられます。",

	sections: [
		{
			id: "heap-data-structure",
			title: "🌳 ヒープデータ構造の基本",
			content:
				"ヒープは完全二分木で、親ノードが子ノードより常に大きい（最大ヒープ）または小さい（最小ヒープ）という条件を満たすデータ構造です。配列として実装でき、インデックスi の親は(i-1)/2、左の子は2i+1、右の子は2i+2で表現できます。この性質により、ルート（インデックス0）には常に最大値（または最小値）が格納されます。",
			importance: "high",
			examples: [
				"最大ヒープ例：[50, 30, 40, 10, 20, 35, 25]",
				"親子関係：50>30, 50>40, 30>10, 30>20, 40>35, 40>25",
				"配列表現により木構造を効率的に管理",
			],
		},

		{
			id: "heapify-operation",
			title: "⚙️ ヒープ化（Heapify）操作",
			content:
				"ヒープ化は、与えられたノードから下向きにヒープ条件を満たすよう調整する操作です。ノードとその子ノードを比較し、必要に応じて位置を交換します。この操作を再帰的に適用することで、部分木全体をヒープ条件に適合させます。ヒープソートの核となる操作で、O(log n)の時間計算量を持ちます。",
			importance: "high",
			examples: [
				"違反ノード検出：親 < 子の場合",
				"最大子ノードと交換",
				"交換後、下位のヒープ条件を再帰的にチェック",
				"ルートまでヒープ条件が満たされるまで継続",
			],
		},

		{
			id: "build-heap-phase",
			title: "🏗️ ヒープ構築フェーズ",
			content:
				"配列全体をヒープ構造に変換する段階です。最後の非葉ノード（インデックス(n/2)-1）から開始して、インデックス0まで逆順にヒープ化操作を実行します。この順序により、各ノードでヒープ化を実行する時点で、その子ノード以下は既にヒープ条件を満たしていることが保証されます。全体でO(n)時間で完了します。",
			importance: "high",
			examples: [
				"開始：最後の非葉ノード（インデックス(n/2)-1）",
				"各ノードで下向きヒープ化を実行",
				"インデックス0（ルート）まで処理",
				"結果：配列全体が最大ヒープに変換",
			],
		},

		{
			id: "sorting-phase",
			title: "📊 ソートフェーズの実行",
			content:
				"ヒープ構築後、実際のソートを実行します。ルート（最大値）を配列の末尾と交換し、ヒープサイズを1減らします。その後、新しいルートに対してヒープ化を実行して、再び最大ヒープを復元します。この処理をヒープサイズが1になるまで繰り返すことで、配列全体が昇順にソートされます。",
			importance: "high",
			examples: [
				"ステップ1：ルート（最大値）を末尾と交換",
				"ステップ2：ヒープサイズを1減らす",
				"ステップ3：新しいルートをヒープ化",
				"ステップ4：ヒープサイズが1になるまで繰り返し",
			],
		},

		{
			id: "time-complexity",
			title: "⏱️ 時間計算量の分析",
			content:
				"ヒープソートの時間計算量は常にO(n log n)です。ヒープ構築がO(n)、ソートフェーズでn-1回のヒープ化操作（各O(log n)）を実行するため、全体でO(n log n)となります。入力データの状態（ソート済み、逆順、ランダム）に関係なく同じ性能を保証します。これは理論的に最適なソート性能の一つです。",
			formula:
				"時間計算量: O(n log n) （全ケース）<br>空間計算量: O(1)<br><br>ヒープ構築: O(n)<br>ソート処理: O(n log n)<br>ヒープ化操作: O(log n)",
			importance: "medium",
			examples: [
				"1000要素：約10,000回の操作（1000 × log₂(1000) ≈ 10,000）",
				"性能保証：最良・平均・最悪すべてO(n log n)",
				"安定性：ヒープソートは不安定ソート",
			],
		},

		{
			id: "in-place-sorting",
			title: "💾 インプレースソートの利点",
			content:
				"ヒープソートの最大の利点は、インプレース（追加メモリをほとんど使わない）でソートできることです。定数個の変数以外、追加の配列や大量のメモリを必要としません。これにより、メモリが制限された環境や、大容量データの処理において有利です。マージソートと比較して、メモリ効率が大幅に優れています。",
			importance: "medium",
			examples: [
				"追加メモリ：O(1) （定数個の変数のみ）",
				"大容量データ処理：メモリ制限環境で有効",
				"組み込みシステム：限られたメモリ資源での利用",
			],
		},

		{
			id: "stability-analysis",
			title: "🔄 安定性の特性",
			content:
				"ヒープソートは「不安定ソート」です。同じ値を持つ要素の相対的な順序が、ソート後に保たれない可能性があります。これは、ヒープ化操作や要素の交換において、元の順序を考慮しないためです。安定性が重要な用途では、マージソートやTimsortなどの安定ソートアルゴリズムの使用を検討する必要があります。",
			importance: "medium",
			examples: [
				"不安定例：[(田中,25), (佐藤,25)] → [(佐藤,25), (田中,25)]",
				"順序変化：同じ値でも元の順序が保たれない",
				"対策：安定性が必要な場合は他のアルゴリズムを選択",
			],
		},

		{
			id: "comparison-with-others",
			title: "🆚 他のソートアルゴリズムとの比較",
			content:
				"ヒープソートは、他の主要なソートアルゴリズムと比較してバランスの取れた特性を持ちます。クイックソートより若干遅いですが性能が保証され、マージソートよりメモリ効率が良く、選択ソートより大幅に高速です。リアルタイムシステムや組み込みシステムなど、性能保証とメモリ効率の両方が重要な場面で選択されます。",
			importance: "high",
			examples: [
				"クイックソート vs ヒープソート：速度 vs 性能保証",
				"マージソート vs ヒープソート：安定性 vs メモリ効率",
				"選択ソート vs ヒープソート：シンプルさ vs 効率性",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実際の応用場面",
			content:
				"ヒープソートは、その性能保証とメモリ効率により、特定の分野で重要な役割を果たしています。優先度付きキューの実装、リアルタイムシステムでの確定的ソート、組み込みシステムのメモリ制限環境、アルゴリズム競技での安全な選択肢として使用されています。また、ヒープデータ構造自体が多くのアルゴリズムの基礎となっています。",
			importance: "low",
			examples: [
				"システム：リアルタイムOS、組み込みシステム",
				"データ構造：優先度付きキュー、ダイクストラ法",
				"競技プログラミング：確実にO(n log n)が必要な場面",
			],
		},
	],
};
