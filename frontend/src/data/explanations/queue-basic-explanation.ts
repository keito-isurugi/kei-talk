/**
 * src/data/explanations/queue-basic-explanation.ts
 *
 * キュー（基本操作）の解説データ
 * FIFO原理とキューデータ構造の学習向け
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * キュー（基本操作）の解説データ
 * FIFO原理の基本から実装、応用まで段階的に説明
 */
export const queueBasicExplanation: ExplanationData = {
	calculationType: "queue_basic",
	title: "キュー（Queue）データ構造とは？",
	overview:
		"キューは「First In, First Out（FIFO）」原理に基づくデータ構造です。最初に追加された要素が最初に取り出される性質を持ち、日常生活の「待ち行列」と同じ概念です。プログラミングでは、タスクスケジューリング、幅優先探索（BFS）、プロセス管理など様々な場面で使用されます。すべての基本操作（enqueue、dequeue、front、rear）がO(1)時間で実行できるため、効率的なデータ処理を実現します。",

	sections: [
		{
			id: "fifo-principle",
			title: "📋 FIFO原理の理解",
			content:
				"FIFO（First In, First Out）は「最初に入れたものが最初に出てくる」という原理です。日常生活では、銀行の窓口待ち、レジの行列、印刷待ちキューなどで見られる概念です。キューでは、要素の追加は一方の端（rear/末尾）で行い、要素の取り出しは反対の端（front/先頭）で行います。この制約により、データの順序が保証され、公平性を保った処理が可能になります。",
			importance: "high",
			examples: [
				"銀行の窓口: 最初に来た人が最初にサービスを受ける",
				"プリンタキュー: 最初に送信された文書が最初に印刷される",
				"コンピュータのタスク: 最初に要求されたタスクが最初に実行される",
				"データ処理: パケットやメッセージの順序保証",
			],
		},

		{
			id: "basic-operations",
			title: "🔧 基本操作の詳細",
			content:
				"キューの基本操作は主に6つあります。enqueue（要素追加）は末尾に新しい要素を追加し、dequeue（要素取出）は先頭から要素を取り出します。front（先頭確認）は先頭要素を削除せずに確認し、rear（末尾確認）は末尾要素を確認します。isEmpty（空判定）とsize（要素数取得）は状態の確認に使用します。これらの操作により、安全で効率的なデータ管理が可能になります。",
			importance: "high",
			examples: [
				"enqueue(5): 末尾に5を追加 → [1,2,3,5]",
				"dequeue(): 先頭要素1を取り出し → [2,3,5]",
				"front(): 先頭要素2を確認（削除なし）",
				"rear(): 末尾要素5を確認（削除なし）",
			],
		},

		{
			id: "implementation-details",
			title: "💻 実装における考慮点",
			content:
				"キューの実装には主に配列ベースと連結リストベースの2つの方法があります。配列ベースは実装が簡単ですが、dequeue操作でshift()を使用すると要素の移動が発生してO(n)時間かかります。効率的な実装では、front/rearポインタを使用したり、連結リストを使用したりしてすべての操作をO(1)時間で実現します。また、サイズ制限のある循環キューや、優先度付きキューなど、応用的な実装も重要です。",
			importance: "medium",
			examples: [
				"配列実装: 簡単だがdequeueが非効率（shift使用時）",
				"ポインタ実装: frontとrearインデックスを使用",
				"連結リスト実装: 動的サイズで全操作がO(1)",
				"循環キュー: 固定サイズでメモリ効率が良い",
			],
		},

		{
			id: "complexity-analysis",
			title: "⚡ 計算量の分析",
			content:
				"理想的なキューの実装では、すべての基本操作がO(1)時間で実行されるべきです。enqueue、dequeue、front、rear、isEmpty、sizeのすべてが定数時間で動作します。空間計算量は格納する要素数nに対してO(n)です。ただし、実装方法によってはdequeue操作がO(n)になる場合もあるため、効率的な実装の選択が重要です。適切な実装により、大量のデータに対しても高速な処理が可能になります。",
			formula:
				"理想的なキューの計算量：<br>時間計算量:<br>- enqueue: O(1)<br>- dequeue: O(1)<br>- front/rear: O(1)<br>- isEmpty/size: O(1)<br><br>空間計算量: O(n) (n = 要素数)",
			importance: "high",
			examples: [
				"効率的実装: 全操作がO(1)で高速",
				"非効率実装: dequeueがO(n)で低速",
				"大量データ: 効率的実装では数百万要素でも高速",
				"リアルタイム: 一定時間での応答が保証される",
			],
		},

		{
			id: "real-world-applications",
			title: "🌐 実世界での応用",
			content:
				"キューは様々な実世界のシステムで重要な役割を果たします。オペレーティングシステムではプロセススケジューリングやI/O管理に使用されます。ネットワークシステムではデータパケットの順序保証や帯域制御に活用されます。Webサーバーではリクエストの処理順序管理、データベースではトランザクション管理、ゲーム開発ではイベント処理やアニメーション管理などで使用されます。これらの応用により、公平で効率的なシステムが実現されています。",
			importance: "medium",
			examples: [
				"OS: プロセススケジューリングとI/O管理",
				"Web: HTTPリクエストの順序処理",
				"データベース: トランザクション待ち行列",
				"ゲーム: イベント処理とアニメーション管理",
			],
		},

		{
			id: "queue-variants",
			title: "🔄 キューの種類と変形",
			content:
				"基本的なキューから派生した様々な種類があります。Deque（両端キュー）は両端での追加・削除が可能で、より柔軟な操作を提供します。Priority Queue（優先度付きキュー）は要素に優先度を付けて管理し、重要度に応じた処理順序を実現します。Circular Queue（循環キュー）は固定サイズでメモリ効率が良く、組み込みシステムなどで使用されます。これらの変形により、様々な要件に対応できます。",
			importance: "medium",
			examples: [
				"Deque: 両端操作でスタックとキューの機能を併用",
				"Priority Queue: 緊急度によるタスク処理",
				"Circular Queue: 組み込みシステムでのバッファ管理",
				"Blocking Queue: マルチスレッド環境での同期処理",
			],
		},

		{
			id: "algorithms-using-queues",
			title: "🔍 キューを使用するアルゴリズム",
			content:
				"キューは多くの重要なアルゴリズムの基礎となっています。幅優先探索（BFS）では、訪問すべきノードをキューで管理することで、最短経路の発見やツリーの全レベル探索を実現します。トポロジカルソートでは依存関係のない要素をキューで管理し、適切な実行順序を決定します。またオペレーティングシステムのスケジューリングアルゴリズムでも、プロセスの実行順序を公平に管理するためにキューが使用されます。",
			importance: "medium",
			examples: [
				"BFS: グラフの幅優先探索で最短経路発見",
				"トポロジカルソート: 依存関係に基づく順序決定",
				"レベル順走査: ツリーの各レベルを順番に処理",
				"Round-Robin: プロセススケジューリングの公平性確保",
			],
		},

		{
			id: "implementation-patterns",
			title: "🏗️ 実装パターンと最適化",
			content:
				"効率的なキューの実装には複数のパターンがあります。動的配列を使用する場合は、capacity managementとamortized analysisが重要です。連結リストを使用する場合は、headとtailポインタの管理が鍵となります。メモリプールを使用したオブジェクトプールパターンや、thread-safeな実装でのロック戦略など、用途に応じた最適化が必要です。また、ガベージコレクションの影響を最小化する実装も重要な考慮点です。",
			importance: "low",
			examples: [
				"Dynamic Array: 容量管理とamortized O(1)操作",
				"Linked List: 動的サイズと一定時間操作",
				"Object Pool: メモリ割り当ての最適化",
				"Lock-free: マルチスレッド環境での高性能実装",
			],
		},

		{
			id: "common-mistakes",
			title: "⚠️ よくある間違いと注意点",
			content:
				"キューの実装と使用において、いくつかの典型的な間違いがあります。空のキューからのdequeue操作は例外処理が必要です。配列実装でのshift()使用は性能問題を引き起こします。マルチスレッド環境では適切な同期処理が必要です。また、メモリリークを防ぐため、不要になったオブジェクトへの参照は適切にクリアする必要があります。これらの問題を理解し、適切に対処することで、堅牢なキューシステムを構築できます。",
			importance: "medium",
			examples: [
				"空キューエラー: dequeue前のisEmpty()チェック",
				"性能問題: shift()の代わりにポインタ使用",
				"競合状態: マルチスレッドでの適切な同期",
				"メモリリーク: 不要オブジェクトの参照クリア",
			],
		},

		{
			id: "learning-progression",
			title: "📚 学習の進め方",
			content:
				"キューの学習は、まず基本概念とFIFO原理の理解から始めます。次に簡単な配列実装を行い、各操作の動作を確認します。その後、効率的な実装（連結リストや循環キュー）に進み、計算量の違いを理解します。応用として、BFSなどのアルゴリズムでの使用例を学習し、最終的には実際のシステム設計での活用方法を習得します。実装と理論の両面から学習することで、深い理解が得られます。",
			importance: "low",
			examples: [
				"基礎: FIFO原理と基本操作の理解",
				"実装: 配列と連結リストでの実装比較",
				"応用: BFS、タスクスケジューリングでの活用",
				"発展: 高性能実装とシステム設計",
			],
		},
	],
};
