/**
 * src/data/explanations/sliding-window-explanation.ts
 *
 * スライディングウィンドウ（尺取り法）の解説データ
 * 配列の部分列を効率的に処理する重要な技法について詳解
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * スライディングウィンドウ（尺取り法）の解説データ
 * 基本概念から高度な応用まで段階的に説明
 */
export const slidingWindowExplanation: ExplanationData = {
	calculationType: "sliding_window",
	title: "スライディングウィンドウ（尺取り法）とは？",
	overview:
		"スライディングウィンドウ（Sliding Window）と尺取り法（Two Pointers）は、配列やリストの連続する部分列を効率的に処理する重要なアルゴリズム技法です。固定サイズまたは可変サイズの「ウィンドウ」を配列上でスライドさせることで、二重ループのO(n²)処理をO(n)に改善できます。文字列処理、部分配列問題、最適化問題など幅広い分野で活用され、競技プログラミングでも頻出の重要な技法です。",

	sections: [
		{
			id: "basic-window-concept",
			title: "🪟 ウィンドウの基本概念",
			content:
				"スライディングウィンドウは、配列上の連続する部分列を「ウィンドウ」として扱い、このウィンドウを効率的にスライドさせる技法です。固定サイズウィンドウでは一定のサイズを維持しながら移動し、可変サイズウィンドウでは条件に応じてサイズを動的に調整します。各ステップで要素の追加・削除を差分的に処理することで、全体の再計算を避けて高効率を実現します。",
			importance: "high",
			examples: [
				"固定ウィンドウ: サイズ3で[1,2,3] → [2,3,4] → [3,4,5]",
				"要素追加: 右端の新要素を加算",
				"要素削除: 左端の旧要素を減算",
				"差分更新: O(1)時間での状態更新",
			],
		},

		{
			id: "two-pointer-technique",
			title: "👆 尺取り法（Two Pointers）",
			content:
				"尺取り法は2つのポインタ（left, right）を使用して範囲を動的に調整する技法です。条件を満たすまで右ポインタを伸ばし、条件を超えたら左ポインタを縮める操作を繰り返します。この伸縮動作が尺取虫の動きに似ていることから「尺取り法」と呼ばれます。各ポインタが配列を最大1回ずつ通過するため、時間計算量はO(n)になります。",
			importance: "high",
			examples: [
				"指定和の部分配列: 和が小さければ右を伸ばす",
				"和が大きければ左を縮める",
				"各ポインタは単調移動のためO(n)",
				"条件判定による動的な範囲調整",
			],
		},

		{
			id: "fixed-vs-variable",
			title: "🔄 固定 vs 可変ウィンドウ",
			content:
				"固定サイズウィンドウは一定のサイズを維持しながらスライドし、移動平均や固定期間の統計計算に適しています。可変サイズウィンドウは条件に応じてサイズが変化し、部分配列和問題や最長部分文字列問題に活用されます。固定では「追加→削除」の単純パターン、可変では「条件判定→拡張/縮小」の柔軟なパターンを持ちます。",
			importance: "high",
			examples: [
				"固定: k日移動平均、固定サイズの最大和",
				"可変: 重複なし最長部分文字列",
				"可変: 指定和以下の最短部分配列",
				"用途に応じた適切なパターン選択",
			],
		},

		{
			id: "optimization-principle",
			title: "⚡ 最適化の原理",
			content:
				"スライディングウィンドウの最適化効果は「重複計算の排除」にあります。ナイーブな方法では各位置で部分配列全体を再計算しますが、ウィンドウ法では前の状態から差分更新のみを行います。この原理により、O(n²)の二重ループがO(n)の線形処理に変換され、特に大規模データで劇的な性能向上を実現します。",
			formula:
				"最適化効果:<br>ナイーブ法: O(n × m) (n: 位置数, m: 平均ウィンドウサイズ)<br>ウィンドウ法: O(n) (差分更新)<br><br>具体例:<br>10000要素, 平均1000要素ウィンドウ<br>ナイーブ: 10^7演算 → ウィンドウ: 10^4演算",
			importance: "high",
			examples: [
				"差分更新: 新要素追加O(1) + 旧要素削除O(1)",
				"状態維持: 和、最大値、文字頻度など",
				"メモリ効率: 追加メモリO(1)または小定数",
				"実時間処理: ストリーミングデータ対応",
			],
		},

		{
			id: "string-processing",
			title: "📝 文字列処理での応用",
			content:
				"スライディングウィンドウは文字列処理で特に威力を発揮します。重複文字がない最長部分文字列、指定パターンを含む最小ウィンドウ、アナグラム検索などの問題で活用されます。文字頻度の管理にはハッシュマップを使用し、ウィンドウの拡張・縮小に応じて頻度を動的に更新します。これにより複雑な文字列問題も効率的に解決できます。",
			importance: "medium",
			examples: [
				"最長非重複部分文字列: abcabcbb → abc (長さ3)",
				"最小ウィンドウ: ADOBECODEBANC でABCを含む最小",
				"アナグラム検索: 固定長ウィンドウでの文字頻度比較",
				"パターンマッチング: KMPの代替手法",
			],
		},

		{
			id: "practical-applications",
			title: "🌍 実用的な応用例",
			content:
				"スライディングウィンドウは多くの実用システムで活用されています。ネットワーク監視での異常検知、金融システムでのリスク分析、IoTセンサーデータの実時間処理、ゲーム開発でのパフォーマンス監視などに使用されます。特にストリーミングデータの処理において、固定メモリで効率的な統計計算を実現する重要な技術です。",
			importance: "medium",
			examples: [
				"ネットワーク: 5分間のトラフィック監視",
				"金融: 移動平均による価格分析",
				"IoT: センサー値の異常検知",
				"ゲーム: FPS計測と品質監視",
			],
		},

		{
			id: "advanced-patterns",
			title: "🔧 高度な応用パターン",
			content:
				"基本的なスライディングウィンドウを発展させた高度なパターンには、複数ウィンドウの同時管理、優先度付きウィンドウ、階層ウィンドウなどがあります。また、セグメント木やdequeと組み合わせることで、より複雑な区間クエリや最値維持が可能になります。これらの応用パターンを理解することで、より複雑な問題にも対応できます。",
			importance: "low",
			examples: [
				"Deque活用: ウィンドウ内最大値をO(1)維持",
				"複数ウィンドウ: 異なるサイズの同時処理",
				"セグメント木連携: 複雑な区間クエリ",
				"階層処理: マルチレベルの時間窓",
			],
		},

		{
			id: "implementation-tips",
			title: "💡 実装のコツと注意点",
			content:
				"スライディングウィンドウの実装では、境界条件の処理が重要です。右ポインタが配列末尾に達した場合の処理、空ウィンドウの扱い、オーバーフローの対策などに注意が必要です。また、状態管理（和、頻度、最大値など）を正確に行い、ポインタの移動と状態更新の同期を保つことが正しい動作のカギとなります。",
			importance: "medium",
			examples: [
				"境界チェック: right < n, left <= right",
				"状態初期化: 最初のウィンドウを適切に設定",
				"オーバーフロー: long long型の使用",
				"デバッグ: 各ステップでの状態確認",
			],
		},

		{
			id: "performance-analysis",
			title: "📊 性能分析と最適化",
			content:
				"スライディングウィンドウの性能は問題の性質によって大きく左右されます。最良の場合は各要素を1回ずつ処理してO(n)、最悪の場合でもO(n)の線形時間を維持します。メモリ使用量は通常O(1)ですが、状態管理の内容によってはO(k)（kは状態のサイズ）になります。実装時はキャッシュ効率も考慮すると、さらなる性能向上が期待できます。",
			importance: "low",
			examples: [
				"時間計算量: 常にO(n)の線形時間",
				"空間計算量: O(1)〜O(k)（状態による）",
				"キャッシュ効率: 連続アクセスで高効率",
				"実装コスト: 比較的シンプルで保守性良好",
			],
		},

		{
			id: "learning-path",
			title: "📈 効果的な学習アプローチ",
			content:
				"スライディングウィンドウの習得は、まず固定サイズの基本問題から始めて、徐々に可変サイズや複雑な条件の問題に進むのが効果的です。各パターンの特徴を理解し、問題を見て適用可能性を素早く判断できるようになることが重要です。また、実装練習を通じて、様々な状態管理パターンに慣れることも大切です。",
			importance: "low",
			examples: [
				"基礎: 固定サイズの和・平均計算",
				"発展: 可変サイズの条件付き探索",
				"応用: 文字列問題や複雑な制約",
				"習熟: パターン認識と素早い実装",
			],
		},
	],
};
