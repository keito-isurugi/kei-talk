/**
 * src/data/explanations/mod-basic-explanation.ts
 *
 * mod計算の基本の解説データ
 * 剰余演算の数学的基礎から暗号学応用まで包括的な学習向け
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * mod計算の基本の解説データ
 * 数論の基礎から現代暗号学への応用まで段階的に説明
 */
export const modBasicExplanation: ExplanationData = {
	calculationType: "mod_basic",
	title: "mod計算とは？",
	overview:
		"mod計算（剰余演算）は、整数を別の整数で割った余りを求める演算です。古代から存在する概念でありながら、現代の暗号学、ハッシュ関数、分散システムなど、コンピュータサイエンスの中核技術を支える基盤的な数学的操作です。O(1)からO(log n)という効率的な計算量を持ち、大規模な数値計算や暗号処理において重要な役割を果たしています。",

	sections: [
		{
			id: "mathematical-foundation",
			title: "📐 数学的基礎と定義",
			content:
				"mod計算は「a mod m = r」という形で表現され、これは「aをmで割った余りがr」という意味です。数学的には、a = q×m + r（0 ≤ r < m）の関係で定義されます。ここでqは商、rは余りです。例えば、17 mod 5 = 2 は、17 = 3×5 + 2 を意味します。この演算は、数論における合同関係の基礎となり、「a ≡ b (mod m)」（aとbはmを法として合同）という概念につながります。",
			importance: "high",
			examples: [
				"17 mod 5 = 2（17 = 3×5 + 2）",
				"100 mod 7 = 2（100 = 14×7 + 2）",
				"-3 mod 5 = 2（-3 = -1×5 + 2）",
				"12 mod 12 = 0（12 = 1×12 + 0）",
			],
		},

		{
			id: "basic-properties",
			title: "🔧 基本的な性質と法則",
			content:
				"mod演算は多くの重要な性質を持ちます。加法性質：(a + b) mod m = ((a mod m) + (b mod m)) mod m、乗法性質：(a × b) mod m = ((a mod m) × (b mod m)) mod m、分配法則：(a × (b + c)) mod m = ((a × b) + (a × c)) mod m。これらの性質により、大きな数の計算を効率化できます。また、べき乗についても (a^n) mod m の形で表現でき、特に高速べき乗アルゴリズムの基礎となります。",
			importance: "high",
			formula:
				"基本性質:<br>(a + b) mod m = ((a mod m) + (b mod m)) mod m<br>(a × b) mod m = ((a mod m) × (b mod m)) mod m<br>(a^n) mod m = ((a mod m)^n) mod m",
			examples: [
				"(15 + 8) mod 7 = ((15 mod 7) + (8 mod 7)) mod 7 = (1 + 1) mod 7 = 2",
				"(12 × 5) mod 11 = ((12 mod 11) × (5 mod 11)) mod 11 = (1 × 5) mod 11 = 5",
				"分配則により大きな計算を小さな部分に分解可能",
				"オーバーフローを防ぎながら正確な計算が可能",
			],
		},

		{
			id: "fast-exponentiation",
			title: "⚡ 高速べき乗計算",
			content:
				"a^n mod m を効率的に計算する高速べき乗アルゴリズムは、指数nを二進法で表現し、「二乗して削減」という手法を用います。ナイーブな方法ではO(n)回の乗算が必要ですが、高速べき乗ではO(log n)回に削減できます。例えば3^13の計算では、13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0 として分解し、3^8, 3^4, 3^1を計算して組み合わせます。これは暗号学において大きな指数での計算を実用的にする重要な技術です。",
			importance: "high",
			formula:
				"高速べき乗アルゴリズム:<br>result = 1<br>while n > 0:<br>&nbsp;&nbsp;if n % 2 == 1: result = (result × base) mod m<br>&nbsp;&nbsp;base = (base × base) mod m<br>&nbsp;&nbsp;n = n // 2",
			examples: [
				"3^13 mod 7: 13(二進) = 1101",
				"段階: 3^1, 3^4, 3^8 を計算",
				"結果: 3^13 = 3^8 × 3^4 × 3^1",
				"計算量: O(log 13) = O(4)回の反復",
			],
		},

		{
			id: "modular-inverse",
			title: "🔄 モジュラ逆元",
			content:
				"モジュラ逆元は、「a × x ≡ 1 (mod m)」を満たすxのことです。これは通常の除法に相当する概念で、暗号学において重要な役割を果たします。逆元が存在する条件は gcd(a, m) = 1、つまりaとmが互いに素であることです。計算には拡張ユークリッドの互除法を使用し、時間計算量はO(log m)です。例えば、3の7を法とする逆元は5で、3×5 = 15 ≡ 1 (mod 7) が成り立ちます。",
			importance: "medium",
			examples: [
				"3の逆元 mod 7 = 5（3×5 = 15 ≡ 1 (mod 7)）",
				"2の逆元 mod 5 = 3（2×3 = 6 ≡ 1 (mod 5)）",
				"6の逆元 mod 7 = 6（6×6 = 36 ≡ 1 (mod 7)）",
				"4は mod 6 で逆元なし（gcd(4,6) = 2 ≠ 1）",
			],
		},

		{
			id: "cryptographic-applications",
			title: "🔐 暗号学での応用",
			content:
				"mod計算は現代暗号学の基盤技術です。RSA暗号では、大きな素数を法とするmod演算により公開鍵暗号を実現します。楕円曲線暗号では有限体上の演算として使用され、ディフィー・ヘルマン鍵交換では離散対数問題の困難性を利用します。これらの暗号方式の安全性は、大きな数でのmod計算の一方向性（計算は簡単だが逆算は困難）に依存しています。また、ハッシュ関数の設計においても重要な役割を果たします。",
			importance: "low",
			examples: [
				"RSA暗号: c = m^e mod n（暗号化）",
				"RSA復号: m = c^d mod n（復号化）",
				"ディフィー・ヘルマン: g^x mod p",
				"楕円曲線: (x, y)座標の有限体演算",
			],
		},

		{
			id: "computational-efficiency",
			title: "🚀 計算効率と最適化",
			content:
				"mod計算の効率性は、使用するアルゴリズムと実装方法に大きく依存します。基本的なmod演算はO(1)ですが、べき乗計算では高速べき乗によりO(log n)を実現できます。大きな数での計算では、モンゴメリ算法やバレット・リダクションなどの特殊な技法が使用されます。また、並列計算やハードウェア実装により、さらなる高速化が可能です。実装時には整数オーバーフローの回避も重要な考慮事項となります。",
			importance: "medium",
			examples: [
				"基本mod: O(1) - 単純な除算余り",
				"べき乗mod: O(log n) - 高速べき乗使用",
				"逆元計算: O(log m) - 拡張ユークリッド法",
				"大数計算: 特殊アルゴリズムで最適化",
			],
		},

		{
			id: "number-theory-connections",
			title: "🔢 数論との関連",
			content:
				"mod計算は数論の多くの概念と深く関連しています。フェルマーの小定理（pが素数のとき a^(p-1) ≡ 1 (mod p)）、オイラーの定理（φ(n)はオイラー関数）、中国剰余定理などの重要な定理の基礎となります。素数判定アルゴリズム（ミラー・ラビン判定法など）や因数分解アルゴリズムでも中核的な役割を果たします。これらの数論的性質は、暗号学の安全性証明や効率的なアルゴリズム設計において不可欠です。",
			importance: "medium",
			examples: [
				"フェルマーの小定理: a^(p-1) ≡ 1 (mod p)",
				"オイラーの定理: a^φ(n) ≡ 1 (mod n)",
				"中国剰余定理: 連立mod方程式の解",
				"素数判定: 確率的アルゴリズムの基礎",
			],
		},

		{
			id: "practical-implementations",
			title: "💻 実装上の考慮事項",
			content:
				"mod計算の実装では、いくつかの重要な点に注意が必要です。負数のmod演算は言語により異なる結果を返すことがあるため、常に正の余りを得るための調整が必要です。大きな数の計算では整数オーバーフローを避けるため、計算途中でmodを取る必要があります。また、ゼロ除算の回避、適切な型選択（32bit vs 64bit整数）、浮動小数点数との使い分けも重要です。パフォーマンスが重要な場合は、ビット演算を活用した最適化も検討されます。",
			importance: "medium",
			examples: [
				"負数対応: ((a % m) + m) % m",
				"オーバーフロー回避: 計算途中でmod適用",
				"型選択: long long使用で64bit精度確保",
				"ビット演算: 2の冪でのmod最適化",
			],
		},

		{
			id: "hash-functions",
			title: "🔗 ハッシュ関数への応用",
			content:
				"mod計算はハッシュ関数の設計において重要な役割を果たします。ハッシュテーブルのインデックス計算、チェックサム算出、分散システムでの一貫性ハッシュなど、様々な場面で使用されます。良いハッシュ関数は、入力データを均等に分散させる性質を持ち、これはmod演算の性質を巧みに利用しています。暗号学的ハッシュ関数（SHA-256など）でも、内部的にmod演算が多用されており、安全性と効率性の両立に貢献しています。",
			importance: "low",
			examples: [
				"ハッシュテーブル: hash(key) mod table_size",
				"チェックサム: データの整合性確認",
				"一貫性ハッシュ: 分散システムでの負荷分散",
				"暗号学的ハッシュ: 内部アルゴリズムの構成要素",
			],
		},

		{
			id: "distributed-systems",
			title: "🌐 分散システムでの活用",
			content:
				"分散システムにおいて、mod計算は負荷分散、データ分散、ノード選択などの重要な機能を提供します。一貫性ハッシュでは、mod演算によりデータを複数のノードに均等に分散させます。分散ID生成では、mod演算により重複のない一意な識別子を生成します。また、分散合意アルゴリズムやレプリケーション戦略でも、mod演算による順序付けや選択が活用されます。これらの応用により、スケーラブルで信頼性の高い分散システムが実現されています。",
			importance: "low",
			examples: [
				"データ分散: shard = hash(key) mod num_shards",
				"ノード選択: node = hash(data) mod num_nodes",
				"分散ID: timestamp + (counter mod max_value)",
				"負荷分散: サーバー選択の均等化",
			],
		},

		{
			id: "educational-value",
			title: "📚 学習価値と発展性",
			content:
				"mod計算の学習は、数学的思考力とプログラミングスキルの両方を向上させる優れた教材です。抽象的な数学概念を具体的なアルゴリズムとして実装することで、理論と実践の橋渡しができます。効率的なアルゴリズム設計の考え方、最適化技法、複雑度解析などの重要概念も学べます。さらに、現代社会を支える暗号技術への理解の入り口としても価値があり、情報セキュリティやプライバシー保護への関心を高める効果も期待できます。",
			importance: "low",
			examples: [
				"数学概念の具体化: 抽象から具体への理解",
				"アルゴリズム設計: 効率性への意識向上",
				"暗号学への入門: 現代技術の理解",
				"問題解決能力: 複合的思考力の育成",
			],
		},

		{
			id: "common-pitfalls",
			title: "⚠️ よくある間違いと注意点",
			content:
				"mod計算の実装や使用において、いくつかの典型的な間違いがあります。負数のmod演算では、言語によって異なる結果が得られる場合があるため、常に正の結果を得るための調整が必要です。大きな数の計算では、オーバーフローを避けるため計算途中でmodを適用することが重要です。また、mod 0による除算エラー、浮動小数点数での精度問題、効率的でないアルゴリズムの選択なども注意が必要です。これらの問題を理解し適切に対処することで、信頼性の高い実装が可能になります。",
			importance: "medium",
			examples: [
				"負数問題: -5 mod 3 の結果が言語依存",
				"オーバーフロー: 大きな数での計算前にmod適用",
				"ゼロ除算: mod 0 のエラーチェック",
				"精度問題: 浮動小数点数でのmod使用注意",
			],
		},
	],
};
