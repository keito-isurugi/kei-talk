/**
 * src/data/explanations/array-basic-explanation.ts
 *
 * 配列（基本操作）の解説データ
 * インデックスベースアクセスとCRUD操作の学習向け
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * 配列（基本操作）の解説データ
 * ランダムアクセスの原理から実装、応用まで段階的に説明
 */
export const arrayBasicExplanation: ExplanationData = {
	calculationType: "array_basic",
	title: "配列（Array）データ構造とは？",
	overview:
		"配列は同じ型の要素を連続したメモリ領域に格納するデータ構造です。インデックスによるランダムアクセスがO(1)時間で可能で、プログラミングの最も基本的なデータ構造として広く使用されています。要素の読み取り・更新は高速ですが、挿入・削除は要素の移動が必要なためO(n)時間かかります。メモリ効率が良く、キャッシュ効率も優秀なため、アルゴリズムとデータ処理の基盤として重要な役割を果たします。",

	sections: [
		{
			id: "random-access-principle",
			title: "🎯 ランダムアクセスの原理",
			content:
				"配列の最大の特徴は、インデックスを使った O(1) 時間でのランダムアクセスです。配列の先頭アドレスと要素サイズが分かれば、任意の要素のメモリアドレスを `先頭アドレス + インデックス × 要素サイズ` で瞬時に計算できます。この特性により、要素数に関係なく一定時間で任意の要素にアクセスできます。連続したメモリ配置のため、空間効率とキャッシュ効率も優秀です。",
			importance: "high",
			examples: [
				"arr[0]: 先頭要素に即座にアクセス",
				"arr[1000]: 1000番目の要素にも同じ時間でアクセス",
				"アドレス計算: base_addr + index × sizeof(element)",
				"メモリ効率: 要素のみを格納、余計なポインタ不要",
			],
		},

		{
			id: "basic-operations",
			title: "🔧 基本操作の詳細",
			content:
				"配列の基本操作には読み取り（access）、更新（update）、挿入（insert）、削除（delete）があります。読み取りと更新は O(1) 時間で実行できますが、挿入と削除は要素の移動が必要なため O(n) 時間かかります。末尾への追加は動的配列では O(1) 償却時間で可能です。検索操作は線形探索で O(n)、ソート済み配列では二分探索で O(log n) になります。",
			importance: "high",
			examples: [
				"access: arr[i] → O(1)で値を取得",
				"update: arr[i] = value → O(1)で値を更新",
				"insert: 中間挿入は要素移動でO(n)",
				"delete: 中間削除も要素移動でO(n)",
			],
		},

		{
			id: "memory-layout",
			title: "💾 メモリレイアウトと効率性",
			content:
				"配列は要素を連続したメモリ領域に格納するため、メモリ効率とキャッシュ効率が優秀です。現代のCPUはキャッシュラインという単位でメモリを読み込むため、配列の隣接要素は同時にキャッシュされ、アクセス速度が向上します。また、メモリの断片化が起こりにくく、メモリ使用量も最小限に抑えられます。この特性により、大量データの処理で高いパフォーマンスを発揮します。",
			importance: "medium",
			examples: [
				"連続配置: arr[0], arr[1], arr[2]が隣接",
				"キャッシュ効率: 一度のロードで複数要素を取得",
				"メモリ効率: ポインタ不要で純粋な要素のみ格納",
				"局所性: 隣接要素への順次アクセスが高速",
			],
		},

		{
			id: "dynamic-vs-static",
			title: "🔄 静的配列と動的配列",
			content:
				"配列には静的配列と動的配列の2種類があります。静的配列はサイズが固定で、コンパイル時にメモリが確保されます。動的配列（JavaScript の Array、Python の list など）はサイズが可変で、必要に応じて容量を拡張します。動的配列では容量拡張時に要素のコピーが発生しますが、償却計算量の概念により、追加操作の平均時間計算量は O(1) になります。",
			importance: "medium",
			examples: [
				"静的配列: int arr[100] - 固定サイズ",
				"動的配列: Array, vector - 可変サイズ",
				"容量拡張: サイズが足りなくなると自動で倍増",
				"償却O(1): 平均的には定数時間での追加",
			],
		},

		{
			id: "complexity-analysis",
			title: "⚡ 計算量の分析",
			content:
				"配列の各操作の計算量は用途によって大きく異なります。ランダムアクセス（読み取り・更新）は O(1) で非常に高速です。挿入・削除は位置によって計算量が変わり、末尾では O(1)、中間では O(n) になります。検索は要素の配置によって O(1)（インデックス指定）から O(n)（線形探索）、O(log n)（二分探索）まで様々です。メモリ使用量は格納する要素数に比例して O(n) です。",
			formula:
				"配列操作の計算量:<br>アクセス・更新: O(1)<br>末尾挿入・削除: O(1) (動的配列)<br>中間挿入・削除: O(n)<br>線形探索: O(n)<br>二分探索: O(log n) (ソート済み)<br><br>空間計算量: O(n)",
			importance: "high",
			examples: [
				"高速操作: 読み取り、更新、末尾操作",
				"低速操作: 中間挿入、削除",
				"検索効率: ソート状態によって大きく変化",
				"メモリ効率: 要素数に比例、オーバーヘッド最小",
			],
		},

		{
			id: "real-world-applications",
			title: "🌐 実世界での応用",
			content:
				"配列は様々な実世界のシステムで基盤技術として使用されています。データベースのレコード管理、画像・音声データの格納、科学計算での行列演算、ゲーム開発での座標管理など、あらゆる分野で活用されています。Web開発では配列を使ったデータの一覧表示や操作が頻繁に行われ、機械学習では多次元配列（テンソル）として数値計算の基盤となっています。",
			importance: "medium",
			examples: [
				"データベース: レコードの格納と高速アクセス",
				"画像処理: ピクセルデータの二次元配列",
				"科学計算: 行列とベクトルの数値演算",
				"Web開発: リスト表示とデータ操作",
			],
		},

		{
			id: "common-algorithms",
			title: "🔍 配列を使用するアルゴリズム",
			content:
				"配列は多くの基本的なアルゴリズムの基盤となっています。ソートアルゴリズム（クイックソート、マージソート、ヒープソートなど）では配列の要素を効率的に並び替えます。探索アルゴリズムでは、線形探索や二分探索で目的の要素を見つけます。動的計画法では結果をテーブル（配列）に格納して部分問題の解を再利用します。また、グラフアルゴリズムでも隣接行列として配列が使用されます。",
			importance: "medium",
			examples: [
				"ソート: クイックソート、マージソート",
				"探索: 線形探索、二分探索",
				"DP: フィボナッチ、ナップサック問題",
				"グラフ: 隣接行列による表現",
			],
		},

		{
			id: "optimization-techniques",
			title: "🚀 最適化技法",
			content:
				"配列操作の効率化には様々な技法があります。メモリプリフェッチングによりキャッシュミスを減らし、ベクトル化により並列処理を活用できます。アクセスパターンの最適化では、行優先・列優先アクセスでキャッシュ効率を改善します。また、配列のサイズが事前に分かる場合は静的配列を使用し、不要な動的メモリ割り当てを避けることで性能を向上させることができます。",
			importance: "low",
			examples: [
				"キャッシュ最適化: 連続アクセスパターンの活用",
				"プリフェッチング: 次のデータを先読み",
				"ベクトル化: SIMD命令による並列処理",
				"メモリ管理: 適切なサイズの事前確保",
			],
		},

		{
			id: "common-mistakes",
			title: "⚠️ よくある間違いと注意点",
			content:
				"配列の使用において、いくつかの典型的な間違いがあります。境界外アクセス（インデックスが範囲を超える）は重大なバグの原因となります。頻繁な中間挿入・削除は性能問題を引き起こすため、用途に応じて適切なデータ構造を選択する必要があります。動的配列では未初期化要素へのアクセスや、削除後の要素への参照も問題となります。これらの問題を理解し、適切に対処することが重要です。",
			importance: "medium",
			examples: [
				"境界外アクセス: arr[length] は無効",
				"性能問題: 頻繁な中間操作は O(n²) に",
				"未初期化: 動的配列の空要素アクセス",
				"参照エラー: 削除後の無効インデックス",
			],
		},

		{
			id: "learning-progression",
			title: "📚 学習の進め方",
			content:
				"配列の学習は、まず基本概念とインデックスアクセスの理解から始めます。次に各操作の計算量を理解し、実装を通じて動作を確認します。その後、ソートや探索などの基本アルゴリズムで配列の活用方法を学習します。応用として、多次元配列や動的配列の使い方を習得し、最終的には性能最適化の技法を学びます。段階的に理解を深めることで、効率的なプログラムが書けるようになります。",
			importance: "low",
			examples: [
				"基礎: インデックスアクセスと基本操作",
				"理論: 計算量と配列の特性理解",
				"実践: ソート・探索アルゴリズムの実装",
				"応用: 多次元配列と最適化技法",
			],
		},
	],
};
